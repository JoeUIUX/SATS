// src/services/reports/leocamReport.ts
import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, BorderStyle, WidthType, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';
import jsPDF from 'jspdf';

// Parameter arrays from leocamCheckout.ts
const pcsVi = ["HEPS1_PDM2_PCS_V", "HEPS1_PDM2_PCS_I"];
const gpsVi = ["HEPS1_PDM2_GPS_5V_V", "HEPS1_PDM2_GPS_5V_I"];
const leocamVi = ["HEPS1_PDM1_OPT_CAM_V", "HEPS1_PDM1_OPT_CAM_I"];

const leocamSet = [
  "Leocam_Sen_Mode", "Leocam_Sen_PWR", "Leocam_Sen_Line_Frame_Rate", "Leocam_Sen_BIT_DEPTH",
  "Leocam_Sen_ROI_1", "Leocam_Sen_ROI_2", "Leocam_Sen_ROI_3", "Leocam_Sen_ROI_4",
  "Leocam_Sen_ROI_5_1", "Leocam_Sen_ROI_5_2", "Leocam_Sen_ROI_5_3", "Leocam_Sen_Gain_Analog",
  "Leocam_Sen_Scan_Direction", "Leocam_Sen_Test_Pattern_Sel"
];

const leocamVarStart = [
  "Leocam_Health_Status", "Leocam_Datetime", 
  "Leocam_CPU_Voltage_1", "Leocam_CPU_Voltage_2", "Leocam_CPU_Voltage_3", "Leocam_CPU_Voltage_4",
  "Leocam_CPU_Temp_1", "Leocam_CPU_Temp_2", "Leocam_CPU_Temp_3", "Leocam_CPU_Temp_4"
];

const leocamVarMiddle = [
  "Leocam_Int_Temp_1", "Leocam_Int_Temp_2", "Leocam_Int_Temp_3", "Leocam_Int_Temp_4",
  "Leocam_Int_Temp_5", "Leocam_Int_Temp_6", "Leocam_Int_Temp_7", "Leocam_Int_Temp_8"
];

const leocamVarConfig = [
  "Leocam_Sen_PWR", "Leocam_Sen_Mode", "Leocam_Sen_Line_Frame_Rate", "Leocam_Sen_BIT_DEPTH", 
  "Leocam_Sen_ROI_1", "Leocam_Sen_ROI_2", "Leocam_Sen_ROI_3", "Leocam_Sen_ROI_4", 
  "Leocam_Sen_ROI_5_1", "Leocam_Sen_ROI_5_2", "Leocam_Sen_ROI_5_3", "Leocam_Sen_Gain_Analog", 
  "Leocam_Sen_Scan_Direction", "Leocam_Sen_Test_Pattern_Sel"
];

const leocamVarEnd = [
  "Leocam_Sen_VOLTAGE", "Leocam_Sen_TEMP_1", "Leocam_Sen_TEMP_2", "Leocam_Sen_Reset"
];

const leocamDiskVars = [
  "Leocam_Disk_Used_1", "Leocam_Disk_Used_2", "Leocam_Disk_Used_3",
  "Leocam_Disk_TEMP_1", "Leocam_Disk_TEMP_2", "Leocam_Disk_TEMP_3", 
  "Leocam_Disk_Lifetime_1", "Leocam_Disk_Lifetime_2", "Leocam_Disk_Lifetime_3",
  "Leocam_Disk_Err_Correction_Count_1", "Leocam_Disk_Err_Correction_Count_2", "Leocam_Disk_Err_Correction_Count_3",
  "Leocam_Disk_Err_Uncorrectable_Count_1", "Leocam_Disk_Err_Uncorrectable_Count_2", "Leocam_Disk_Err_Uncorrectable_Count_3",
  "Leocam_Disk_Total_Bytes_Read_1", "Leocam_Disk_Total_Bytes_Read_2", "Leocam_Disk_Total_Bytes_Read_3",
  "Leocam_Disk_Total_Bytes_Written_1", "Leocam_Disk_Total_Bytes_Written_2", "Leocam_Disk_Total_Bytes_Written_3",
  "Leocam_Disk_List_Datasets", "Leocam_Disk_List_Datafiles_in_Dataset"
];

const leocamStat = [
  "PCS_Leocam_Cmd_Count", "PCS_Leocam_Ack_Count", "PCS_Leocam_Timeout_Count", "PCS_Leocam_Error_Count"
];

/**
 * Generate both Word document and PDF reports for LEOCAM checkout results
 * 
 * @param results The LEOCAM test results
 * @returns A promise that resolves to the filename of the saved reports
 */
export async function generateLEOCAMReport(results: any): Promise<string> {
  try {
    // Generate both Word and PDF reports
    const wordFilename = await generateLEOCAMWordReport(results);
    const pdfFilename = await generateLEOCAMPDFReport(results);
    
    return `${wordFilename} and ${pdfFilename}`;
  } catch (error) {
    console.error('‚ùå Error generating LEOCAM reports:', error);
    throw new Error(`Failed to generate LEOCAM reports: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a Word document report for LEOCAM checkout results
 * 
 * @param results The LEOCAM test results
 * @returns A promise that resolves to the filename of the saved report
 */
async function generateLEOCAMWordReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `LEOCAM_Checkout_${dateStr}_${timeStr}.docx`;
  
  console.log(`üìù Generating LEOCAM Word report: ${filename}`);
  
  // Create the document
  const doc = new Document({
    sections: [{
      properties: {},
      children: [
        // Title
        new Paragraph({
          text: "LEOCAM Automated Self Check Out Test Report",
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 200 }
        }),
        
        // Test metadata
        new Paragraph({
          text: `Test Version: 24.3.21`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Date: ${now.toLocaleDateString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Time: ${now.toLocaleTimeString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Generated by: SATS - Satellite Automated Testing System`,
          spacing: { after: 200 }
        }),
        
        // Test Summary
        new Paragraph({
          text: "Test Summary",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`,
          spacing: { after: 100 }
        }),
        
        // Separator
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Voltage Current On Summary
        new Paragraph({
          text: "* Voltage Current On Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        ...createVoltageOnParagraphs(results),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // LEOCAM Configuration section
        new Paragraph({
          text: "* LEOCAM Configuration:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        ...createConfigurationParagraphs(results),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // LEOCAM Telemetry section
        new Paragraph({
          text: "* LEOCAM Telemetry:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        ...createTelemetryParagraphs(results),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "Statistics : -",
          spacing: { after: 100 }
        }),
        
        ...createStatisticsParagraphs(results),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // Voltage Current Off Summary
        new Paragraph({
          text: "* Voltage Current Off Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        ...createVoltageOffParagraphs(results),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Page break for Raw Parameters
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // Raw Parameters Section
        new Paragraph({
          text: "* Raw Parameter Values:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        ...createRawParametersParagraphs(results),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Test Completion Summary
        new Paragraph({
          text: "* Test Completion Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: results.error ? `Test completed with errors: ${results.error}` : "All tests completed successfully",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Report generated: ${now.toLocaleString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
      ]
    }]
  });
  
  try {
    // Generate the document
    console.log('üîÑ Generating Word document...');
    const buffer = await Packer.toBuffer(doc);
    
    // Save the file using file-saver (this will save to the user's default Downloads folder)
    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
    saveAs(blob, filename);
    
    console.log(`‚úÖ LEOCAM Word report saved successfully: ${filename}`);
    
    // Mark the report as generated
    if (results && typeof results === 'object') {
      results.reportGenerated = true;
    }
    
    return filename;
  } catch (error) {
    console.error('‚ùå Error generating LEOCAM Word report:', error);
    throw new Error(`Failed to generate LEOCAM Word report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a PDF report for LEOCAM checkout results
 * 
 * @param results The LEOCAM test results
 * @returns A promise that resolves to the filename of the saved PDF report
 */
async function generateLEOCAMPDFReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `LEOCAM_Checkout_${dateStr}_${timeStr}.pdf`;
  
  console.log(`üìù Generating LEOCAM PDF report: ${filename}`);
  
  try {
    // Create new PDF document
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Set up the document
    let yPosition = 20;
    const pageWidth = pdf.internal.pageSize.width;
    const pageHeight = pdf.internal.pageSize.height;
    const margin = 20;
    const contentWidth = pageWidth - (2 * margin);

    // Helper function to check if we need a new page
    const checkNewPage = (requiredSpace: number = 20) => {
      if (yPosition + requiredSpace > pageHeight - 30) {
        pdf.addPage();
        yPosition = 20;
        return true;
      }
      return false;
    };

    // Title
    pdf.setFontSize(18);
    pdf.setFont('helvetica', 'bold');
    pdf.text('LEOCAM Automated Self Check Out Test Report', margin, yPosition);
    yPosition += 15;

    // Subtitle
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Generated by SATS - Satellite Automated Testing System', margin, yPosition);
    yPosition += 10;

    // Test metadata
    pdf.setFontSize(10);
    pdf.text(`Test Date: ${now.toLocaleDateString()}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Test Time: ${now.toLocaleTimeString()}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`, margin, yPosition);
    yPosition += 15;

    // Add a separator line
    pdf.line(margin, yPosition, pageWidth - margin, yPosition);
    yPosition += 10;

    // Voltage Current On Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Voltage Current On Summary', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.voltageTests) {
      const voltageData = results.voltageTests;
      
      // GPS
      if (voltageData.gps) {
        pdf.text(`GPS Voltage: ${parseFloat(voltageData.gps.voltage || "0").toFixed(3)} V [${voltageData.gps.passInitial ? 'PASS' : 'FAIL'}]`, margin, yPosition);
        yPosition += 6;
        pdf.text(`GPS Current: ${parseFloat(voltageData.gps.current || "0").toFixed(3)} A`, margin, yPosition);
        yPosition += 8;
      }
      
      // PCS
      if (voltageData.pcs) {
        pdf.text(`PCS Voltage: ${parseFloat(voltageData.pcs.voltage || "0").toFixed(3)} V [${voltageData.pcs.passInitial ? 'PASS' : 'FAIL'}]`, margin, yPosition);
        yPosition += 6;
        pdf.text(`PCS Current: ${parseFloat(voltageData.pcs.current || "0").toFixed(3)} A`, margin, yPosition);
        yPosition += 8;
      }
      
      // LEOCAM
      if (voltageData.leocam) {
        pdf.text(`LEOCAM Voltage: ${parseFloat(voltageData.leocam.voltage || "0").toFixed(3)} V [${voltageData.leocam.passInitial ? 'PASS' : 'FAIL'}]`, margin, yPosition);
        yPosition += 6;
        pdf.text(`LEOCAM Current: ${parseFloat(voltageData.leocam.current || "0").toFixed(3)} A`, margin, yPosition);
        yPosition += 8;
      }
    } else {
      pdf.text('Voltage test information not available', margin, yPosition);
      yPosition += 6;
    }
    yPosition += 10;

    // LEOCAM Configuration Section
    checkNewPage(50);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('LEOCAM Configuration', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.leocamConfig) {
      const config = results.leocamConfig;
      
      pdf.text(`Sensor Mode: ${config.sensorMode || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Sensor Power: ${config.sensorPower || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Sensor Line Frame Rate: ${config.sensorLineFrameRate || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Sensor Bit Depth: ${config.sensorBitDepth || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Sensor ROI 1: ${config.sensorRoi1 || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Sensor ROI 2: ${config.sensorRoi2 || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Sensor ROI 3: ${config.sensorRoi3 || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Sensor ROI 4: ${config.sensorRoi4 || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Sensor Gain Analog: ${config.sensorGainAnalog || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Sensor Scan Direction: ${config.sensorScanDirection || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Sensor Test Pattern Select: ${config.sensorTestPatternSel || 'N/A'}`, margin, yPosition);
      yPosition += 6;
    } else {
      pdf.text('LEOCAM configuration information not available', margin, yPosition);
      yPosition += 6;
    }
    yPosition += 15;

    // LEOCAM Telemetry Section
    checkNewPage(60);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('LEOCAM Telemetry', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.leocamTelemetry) {
      const telemetry = results.leocamTelemetry;
      
      pdf.text(`Health Status: ${telemetry.healthStatus || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Current Date Time: ${telemetry.datetime || 'N/A'}`, margin, yPosition);
      yPosition += 8;
      
      // CPU Voltages
      const cpuVoltages = telemetry.cpuVoltages || [];
      for (let i = 0; i < Math.min(cpuVoltages.length, 4); i++) {
        checkNewPage(6);
        pdf.text(`CPU Voltage ${i + 1}: ${cpuVoltages[i] || 'N/A'} V`, margin, yPosition);
        yPosition += 6;
      }
      
      // CPU Temperatures
      const cpuTemperatures = telemetry.cpuTemperatures || [];
      for (let i = 0; i < Math.min(cpuTemperatures.length, 4); i++) {
        checkNewPage(6);
        pdf.text(`CPU Temperature ${i + 1}: ${cpuTemperatures[i] || 'N/A'} ¬∞C`, margin, yPosition);
        yPosition += 6;
      }
      
      // Internal Temperatures
      const internalTemperatures = telemetry.internalTemperatures || [];
      for (let i = 0; i < Math.min(internalTemperatures.length, 8); i++) {
        checkNewPage(6);
        pdf.text(`Internal Temperature ${i + 1}: ${internalTemperatures[i] || 'N/A'} ¬∞C`, margin, yPosition);
        yPosition += 6;
      }
      
      checkNewPage(6);
      pdf.text(`Sensor Voltage: ${telemetry.sensorVoltage || 'N/A'} V`, margin, yPosition);
      yPosition += 6;
      
      // Sensor Temperatures
      const sensorTemperatures = telemetry.sensorTemperatures || [];
      for (let i = 0; i < Math.min(sensorTemperatures.length, 2); i++) {
        checkNewPage(6);
        pdf.text(`Sensor Temperature ${i + 1}: ${sensorTemperatures[i] || 'N/A'} ¬∞C`, margin, yPosition);
        yPosition += 6;
      }
      
      checkNewPage(6);
      pdf.text(`Sensor Reset: ${telemetry.sensorReset || 'N/A'}`, margin, yPosition);
      yPosition += 8;
      
      // Disk data
      const diskUsed = telemetry.diskUsed || [];
      for (let i = 0; i < Math.min(diskUsed.length, 3); i++) {
        checkNewPage(6);
        pdf.text(`Disk Used ${i + 1}: ${diskUsed[i] || 'N/A'} Kbytes`, margin, yPosition);
        yPosition += 6;
      }
      
      const diskTemperatures = telemetry.diskTemperatures || [];
      for (let i = 0; i < Math.min(diskTemperatures.length, 3); i++) {
        checkNewPage(6);
        pdf.text(`Disk Temperature ${i + 1}: ${diskTemperatures[i] || 'N/A'} ¬∞C`, margin, yPosition);
        yPosition += 6;
      }
      
    } else {
      pdf.text('LEOCAM telemetry information not available', margin, yPosition);
      yPosition += 6;
    }
    yPosition += 15;

    // Statistics Section
    checkNewPage(30);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Statistics', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.leocamStatistics) {
      const stats = results.leocamStatistics;
      pdf.text(`Command Count: ${stats.commandCount || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Acknowledge Count: ${stats.acknowledgeCount || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Timeout Count: ${stats.timeoutCount || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Error Count: ${stats.errorCount || 'N/A'}`, margin, yPosition);
      yPosition += 6;
    } else {
      pdf.text('Statistics information not available', margin, yPosition);
      yPosition += 6;
    }
    yPosition += 15;

    // Voltage Current Off Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Voltage Current Off Summary', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.voltageTests) {
      const voltageData = results.voltageTests;
      
      // GPS
      if (voltageData.gps) {
        pdf.text(`GPS Voltage: ${parseFloat(voltageData.gps.voltage || "0").toFixed(3)} V [${voltageData.gps.passFinal ? 'PASS' : 'FAIL'}]`, margin, yPosition);
        yPosition += 6;
        pdf.text(`GPS Current: ${parseFloat(voltageData.gps.current || "0").toFixed(3)} A`, margin, yPosition);
        yPosition += 8;
      }
      
      // PCS
      if (voltageData.pcs) {
        pdf.text(`PCS Voltage: ${parseFloat(voltageData.pcs.voltage || "0").toFixed(3)} V [${voltageData.pcs.passFinal ? 'PASS' : 'FAIL'}]`, margin, yPosition);
        yPosition += 6;
        pdf.text(`PCS Current: ${parseFloat(voltageData.pcs.current || "0").toFixed(3)} A`, margin, yPosition);
        yPosition += 8;
      }
      
      // LEOCAM
      if (voltageData.leocam) {
        pdf.text(`LEOCAM Voltage: ${parseFloat(voltageData.leocam.voltage || "0").toFixed(3)} V [${voltageData.leocam.passFinal ? 'PASS' : 'FAIL'}]`, margin, yPosition);
        yPosition += 6;
        pdf.text(`LEOCAM Current: ${parseFloat(voltageData.leocam.current || "0").toFixed(3)} A`, margin, yPosition);
        yPosition += 8;
      }
    } else {
      pdf.text('Final voltage test information not available', margin, yPosition);
      yPosition += 6;
    }
    yPosition += 15;

    // Raw Parameters Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Raw Parameter Values', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(9); // Smaller font for parameter tables
    pdf.setFont('helvetica', 'normal');
    
    // Add raw parameters to PDF
    yPosition = addRawParametersToPDF(pdf, results, margin, yPosition, pageHeight, checkNewPage);

    // Add footer to all pages
    const totalPages = pdf.internal.pages.length - 1;
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 20, pageHeight - 10);
      pdf.text(`Generated: ${now.toLocaleString()}`, margin, pageHeight - 10);
    }

    // Save the PDF
    pdf.save(filename);

    console.log(`‚úÖ LEOCAM PDF report saved successfully: ${filename}`);
    return filename;

  } catch (error) {
    console.error('‚ùå Error generating LEOCAM PDF report:', error);
    throw new Error(`Failed to generate LEOCAM PDF report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Helper functions to create document paragraphs

/**
 * Create paragraphs for the Voltage On section
 */
function createVoltageOnParagraphs(results: any): Paragraph[] {
  const gpsVoltage = parseFloat(results.voltageTests?.gps?.voltage || "0").toFixed(3);
  const gpsCurrent = parseFloat(results.voltageTests?.gps?.current || "0").toFixed(3);
  const gpsStatus = results.voltageTests?.gps?.passInitial ? "[PASS]" : "[FAIL]";
  
  const pcsVoltage = parseFloat(results.voltageTests?.pcs?.voltage || "0").toFixed(3);
const pcsCurrent = parseFloat(results.voltageTests?.pcs?.current || "0").toFixed(3);
  const pcsStatus = results.voltageTests?.pcs?.passInitial ? "[PASS]" : "[FAIL]";
  
  const leocamVoltage = parseFloat(results.voltageTests?.leocam?.voltage || "0").toFixed(3);
  const leocamCurrent = parseFloat(results.voltageTests?.leocam?.current || "0").toFixed(3);
  const leocamStatus = results.voltageTests?.leocam?.passInitial ? "[PASS]" : "[FAIL]";
  
  return [
    new Paragraph(`GPS Voltage     : ${padString(gpsVoltage, 6)} V    ${gpsStatus}`),
    new Paragraph(`GPS Current     : ${padString(gpsCurrent, 6)} A`),
    new Paragraph(``),
    new Paragraph(`PCS Voltage     : ${padString(pcsVoltage, 6)} V    ${pcsStatus}`),
    new Paragraph(`PCS Current     : ${padString(pcsCurrent, 6)} A`),
    new Paragraph(``),
    new Paragraph(`LEOCAM Voltage  : ${padString(leocamVoltage, 6)} V    ${leocamStatus}`),
    new Paragraph(`LEOCAM Current  : ${padString(leocamCurrent, 6)} A`)
  ];
}

/**
 * Create paragraphs for the Configuration section
 */
function createConfigurationParagraphs(results: any): Paragraph[] {
  const config = results.leocamConfig || {};
  
  return [
    new Paragraph(`Sensor Mode                 : ${config.sensorMode || 'N/A'}`),
    new Paragraph(`Sensor Power                : ${config.sensorPower || 'N/A'}`),
    new Paragraph(`Sensor Line Frame Rate      : ${config.sensorLineFrameRate || 'N/A'}`),
    new Paragraph(`Sensor Bit Depth            : ${config.sensorBitDepth || 'N/A'}`),
    new Paragraph(`Sensor ROI 1                : ${config.sensorRoi1 || 'N/A'}`),
    new Paragraph(`Sensor ROI 2                : ${config.sensorRoi2 || 'N/A'}`),
    new Paragraph(`Sensor ROI 3                : ${config.sensorRoi3 || 'N/A'}`),
    new Paragraph(`Sensor ROI 4                : ${config.sensorRoi4 || 'N/A'}`),
    new Paragraph(`Sensor ROI 5_1              : ${config.sensorRoi5_1 || 'N/A'}`),
    new Paragraph(`Sensor ROI 5_2              : ${config.sensorRoi5_2 || 'N/A'}`),
    new Paragraph(`Sensor ROI 5_3              : ${config.sensorRoi5_3 || 'N/A'}`),
    new Paragraph(`Sensor Gain Analog          : ${config.sensorGainAnalog || 'N/A'}`),
    new Paragraph(`Sensor Scan Direction       : ${config.sensorScanDirection || 'N/A'}`),
    new Paragraph(`Sensor Test Pattern Select  : ${config.sensorTestPatternSel || 'N/A'}`)
  ];
}

/**
 * Create paragraphs for the Telemetry section
 */
function createTelemetryParagraphs(results: any): Paragraph[] {
  const telemetry = results.leocamTelemetry || {};
  const paragraphs: Paragraph[] = [];
  
  // Add Health Status and DateTime
  paragraphs.push(new Paragraph(`Health Status                       : ${telemetry.healthStatus || 'N/A'}`));
  paragraphs.push(new Paragraph(`Current Date Time                   : ${telemetry.datetime || 'N/A'}`));
  
  // Add CPU Voltages
  const cpuVoltages = telemetry.cpuVoltages || [];
  for (let i = 0; i < cpuVoltages.length && i < 4; i++) {
    paragraphs.push(new Paragraph(`CPU Voltage ${i + 1}                       : ${cpuVoltages[i] || 'N/A'} V`));
  }
  
  // Add CPU Temperatures
  const cpuTemperatures = telemetry.cpuTemperatures || [];
  for (let i = 0; i < cpuTemperatures.length && i < 4; i++) {
    paragraphs.push(new Paragraph(`CPU Temperature ${i + 1}                   : ${cpuTemperatures[i] || 'N/A'} deg C`));
  }
  
  // Add Internal Temperatures
  const internalTemperatures = telemetry.internalTemperatures || [];
  for (let i = 0; i < internalTemperatures.length && i < 8; i++) {
    paragraphs.push(new Paragraph(`Internal Temperature ${i + 1}              : ${internalTemperatures[i] || 'N/A'} deg C`));
  }
  
  // Add sensor-specific data
  paragraphs.push(new Paragraph(`Sensor Voltage                      : ${telemetry.sensorVoltage || 'N/A'} V`));
  
  const sensorTemperatures = telemetry.sensorTemperatures || [];
  for (let i = 0; i < sensorTemperatures.length && i < 2; i++) {
    paragraphs.push(new Paragraph(`Sensor Temperature ${i + 1}                : ${sensorTemperatures[i] || 'N/A'} deg C`));
  }
  
  paragraphs.push(new Paragraph(`Sensor Reset                        : ${telemetry.sensorReset || 'N/A'}`));
  
  // Add disk data
  const diskUsed = telemetry.diskUsed || [];
  for (let i = 0; i < diskUsed.length && i < 3; i++) {
    paragraphs.push(new Paragraph(`Disk Used ${i + 1}                         : ${diskUsed[i] || 'N/A'} Kbytes`));
  }
  
  const diskTemperatures = telemetry.diskTemperatures || [];
  for (let i = 0; i < diskTemperatures.length && i < 3; i++) {
    paragraphs.push(new Paragraph(`Disk Temperature ${i + 1}                  : ${diskTemperatures[i] || 'N/A'} deg C`));
  }
  
  const diskLifetimes = telemetry.diskLifetimes || [];
  for (let i = 0; i < diskLifetimes.length && i < 3; i++) {
    paragraphs.push(new Paragraph(`Disk Lifetime ${i + 1}                     : ${diskLifetimes[i] || 'N/A'} hours`));
  }
  
  const diskErrorCorrectionCounts = telemetry.diskErrorCorrectionCounts || [];
  for (let i = 0; i < diskErrorCorrectionCounts.length && i < 3; i++) {
    paragraphs.push(new Paragraph(`Disk Error Correction Count ${i + 1}       : ${diskErrorCorrectionCounts[i] || 'N/A'}`));
  }
  
  const diskErrorUncorrectableCounts = telemetry.diskErrorUncorrectableCounts || [];
  for (let i = 0; i < diskErrorUncorrectableCounts.length && i < 3; i++) {
    paragraphs.push(new Paragraph(`Disk Error Uncorrectable Count ${i + 1}    : ${diskErrorUncorrectableCounts[i] || 'N/A'}`));
  }
  
  const diskTotalBytesRead = telemetry.diskTotalBytesRead || [];
  for (let i = 0; i < diskTotalBytesRead.length && i < 3; i++) {
    paragraphs.push(new Paragraph(`Disk Total Bytes Read ${i + 1}             : ${diskTotalBytesRead[i] || 'N/A'} MiB`));
  }

  const diskTotalBytesWritten = telemetry.diskTotalBytesWritten || [];
  for (let i = 0; i < diskTotalBytesWritten.length && i < 3; i++) {
    paragraphs.push(new Paragraph(`Disk Total Bytes Written ${i + 1}          : ${diskTotalBytesWritten[i] || 'N/A'} MiB`));
  }
  
  paragraphs.push(new Paragraph(`Disk List Datasets                  : ${telemetry.diskListDatasets || 'N/A'}`));
  paragraphs.push(new Paragraph(`Disk List Datafiles in Dataset      : ${telemetry.diskListDatafilesInDataset || 'N/A'}`));
  
  return paragraphs;
}

/**
 * Create paragraphs for the Statistics section
 */
function createStatisticsParagraphs(results: any): Paragraph[] {
  const stats = results.leocamStatistics || {};
  
  return [
    new Paragraph(`Command Count       : ${stats.commandCount || 'N/A'}`),
    new Paragraph(`Acknowledge Count   : ${stats.acknowledgeCount || 'N/A'}`),
    new Paragraph(`Timeout Count       : ${stats.timeoutCount || 'N/A'}`),
    new Paragraph(`Error Count         : ${stats.errorCount || 'N/A'}`)
  ];
}

/**
 * Create paragraphs for the Voltage Off section
 */
function createVoltageOffParagraphs(results: any): Paragraph[] {
  const gpsVoltage = parseFloat(results.voltageTests?.gps?.voltage || "0").toFixed(3);
  const gpsCurrent = parseFloat(results.voltageTests?.gps?.current || "0").toFixed(3);
  const gpsStatus = results.voltageTests?.gps?.passFinal ? "[PASS]" : "[FAIL]";
  
  const pcsVoltage = parseFloat(results.voltageTests?.pcs?.voltage || "0").toFixed(3);
  const pcsCurrent = parseFloat(results.voltageTests?.pcs?.current || "0").toFixed(3);
  const pcsStatus = results.voltageTests?.pcs?.passFinal ? "[PASS]" : "[FAIL]";
  
  const leocamVoltage = parseFloat(results.voltageTests?.leocam?.voltage || "0").toFixed(3);
  const leocamCurrent = parseFloat(results.voltageTests?.leocam?.current || "0").toFixed(3);
  const leocamStatus = results.voltageTests?.leocam?.passFinal ? "[PASS]" : "[FAIL]";
  
  return [
    new Paragraph(`GPS Voltage     : ${padString(gpsVoltage, 6)} V    ${gpsStatus}`),
    new Paragraph(`GPS Current     : ${padString(gpsCurrent, 6)} A`),
    new Paragraph(``),
    new Paragraph(`PCS Voltage     : ${padString(pcsVoltage, 6)} V    ${pcsStatus}`),
    new Paragraph(`PCS Current     : ${padString(pcsCurrent, 6)} A`),
    new Paragraph(``),
    new Paragraph(`LEOCAM Voltage  : ${padString(leocamVoltage, 6)} V    ${leocamStatus}`),
    new Paragraph(`LEOCAM Current  : ${padString(leocamCurrent, 6)} A`)
  ];
}

/**
 * Create paragraphs for the Raw Parameters section
 */
function createRawParametersParagraphs(results: any): Paragraph[] {
  const rawParams = results.rawParameters || {};
  const paragraphs: Paragraph[] = [];
  
  // Add section header
  paragraphs.push(new Paragraph({
    text: "All raw parameter values as read from the hardware:",
    spacing: { after: 100 }
  }));
  
  // Voltage and Current Parameters
  paragraphs.push(new Paragraph({
    text: "Voltage and Current Parameters:",
    spacing: { before: 100, after: 50 }
  }));
  
  [...pcsVi, ...gpsVi, ...leocamVi].forEach(param => {
    paragraphs.push(new Paragraph(`${param.padEnd(35)} : ${rawParams[param] || 'N/A'}`));
  });
  
  // LEOCAM Sensor Configuration Parameters
  paragraphs.push(new Paragraph({
    text: "LEOCAM Sensor Configuration Parameters:",
    spacing: { before: 100, after: 50 }
  }));
  
  leocamSet.forEach(param => {
    paragraphs.push(new Paragraph(`${param.padEnd(35)} : ${rawParams[param] || 'N/A'}`));
  });
  
  // LEOCAM Telemetry Start Parameters
  paragraphs.push(new Paragraph({
    text: "LEOCAM Telemetry Start Parameters:",
    spacing: { before: 100, after: 50 }
  }));
  
  leocamVarStart.forEach(param => {
    paragraphs.push(new Paragraph(`${param.padEnd(35)} : ${rawParams[param] || 'N/A'}`));
  });
  
  // LEOCAM Internal Temperature Parameters
  paragraphs.push(new Paragraph({
    text: "LEOCAM Internal Temperature Parameters:",
    spacing: { before: 100, after: 50 }
  }));
  
  leocamVarMiddle.forEach(param => {
    paragraphs.push(new Paragraph(`${param.padEnd(35)} : ${rawParams[param] || 'N/A'}`));
  });
  
  // LEOCAM Configuration Readback Parameters
  paragraphs.push(new Paragraph({
    text: "LEOCAM Configuration Readback Parameters:",
    spacing: { before: 100, after: 50 }
  }));
  
  leocamVarConfig.forEach(param => {
    paragraphs.push(new Paragraph(`${param.padEnd(35)} : ${rawParams[param] || 'N/A'}`));
  });
  
  // LEOCAM Sensor End Parameters
  paragraphs.push(new Paragraph({
    text: "LEOCAM Sensor End Parameters:",
    spacing: { before: 100, after: 50 }
  }));
  
  leocamVarEnd.forEach(param => {
    paragraphs.push(new Paragraph(`${param.padEnd(35)} : ${rawParams[param] || 'N/A'}`));
  });
  
  // LEOCAM Disk Parameters
  paragraphs.push(new Paragraph({
    text: "LEOCAM Disk Parameters:",
    spacing: { before: 100, after: 50 }
  }));
  
  leocamDiskVars.forEach(param => {
    paragraphs.push(new Paragraph(`${param.padEnd(35)} : ${rawParams[param] || 'N/A'}`));
  });
  
  // LEOCAM Statistics Parameters
  paragraphs.push(new Paragraph({
    text: "LEOCAM Statistics Parameters:",
    spacing: { before: 100, after: 50 }
  }));
  
  leocamStat.forEach(param => {
    paragraphs.push(new Paragraph(`${param.padEnd(35)} : ${rawParams[param] || 'N/A'}`));
  });
  
  return paragraphs;
}

/**
 * Add raw parameters to PDF
 */
function addRawParametersToPDF(pdf: any, results: any, margin: number, startYPosition: number, pageHeight: number, checkNewPage: Function): number {
  const rawParams = results.rawParameters || {};
  let yPosition = startYPosition;
  
  // Helper function to add a section header
  const addSectionHeader = (title: string) => {
    // Check if we need more space for header + at least 3 parameter lines
    if (yPosition + 25 > pageHeight - 30) {
      pdf.addPage();
      yPosition = 20;
    }
    
    pdf.setFontSize(11);
    pdf.setFont('helvetica', 'bold');
    pdf.text(title, margin, yPosition);
    yPosition += 8;
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'normal');
  };
  
  // Helper function to add parameters with better page break handling
  const addParameters = (params: string[]) => {
    params.forEach(param => {
      // Check if we need a new page (allow space for parameter line)
      if (yPosition + 6 > pageHeight - 30) {
        pdf.addPage();
        yPosition = 20;
      }
      
      const value = rawParams[param] || 'N/A';
      // Truncate very long parameter names/values to fit on page
      const truncatedParam = param.length > 40 ? param.substring(0, 37) + '...' : param;
      const truncatedValue = value.toString().length > 30 ? value.toString().substring(0, 27) + '...' : value;
      
      pdf.text(`${truncatedParam}: ${truncatedValue}`, margin, yPosition);
      yPosition += 5;
    });
    yPosition += 3; // Add small gap after each section
  };
  
  try {
    // Voltage and Current Parameters
    addSectionHeader('Voltage and Current Parameters:');
    addParameters([...pcsVi, ...gpsVi, ...leocamVi]);
    
    // LEOCAM Sensor Configuration Parameters  
    addSectionHeader('LEOCAM Sensor Configuration Parameters:');
    addParameters(leocamSet);
    
    // LEOCAM Telemetry Start Parameters
    addSectionHeader('LEOCAM Telemetry Start Parameters:');
    addParameters(leocamVarStart);
    
    // LEOCAM Internal Temperature Parameters
    addSectionHeader('LEOCAM Internal Temperature Parameters:');
    addParameters(leocamVarMiddle);
    
    // LEOCAM Configuration Readback Parameters
    addSectionHeader('LEOCAM Configuration Readback Parameters:');
    addParameters(leocamVarConfig);
    
    // LEOCAM Sensor End Parameters
    addSectionHeader('LEOCAM Sensor End Parameters:');
    addParameters(leocamVarEnd);
    
    // LEOCAM Disk Parameters (split into smaller chunks due to length)
    addSectionHeader('LEOCAM Disk Usage Parameters:');
    addParameters(leocamDiskVars.filter(param => param.includes('Used') || param.includes('TEMP')));
    
    addSectionHeader('LEOCAM Disk Lifetime Parameters:');
    addParameters(leocamDiskVars.filter(param => param.includes('Lifetime')));
    
    addSectionHeader('LEOCAM Disk Error Parameters:');
    addParameters(leocamDiskVars.filter(param => param.includes('Err')));
    
    addSectionHeader('LEOCAM Disk I/O Parameters:');
    addParameters(leocamDiskVars.filter(param => param.includes('Bytes')));
    
    addSectionHeader('LEOCAM Disk List Parameters:');
    addParameters(leocamDiskVars.filter(param => param.includes('List')));
    
    // LEOCAM Statistics Parameters
    addSectionHeader('LEOCAM Statistics Parameters:');
    addParameters(leocamStat);
    
  } catch (error) {
    console.error('Error adding raw parameters to PDF:', error);
    // Add error message to PDF
    if (yPosition + 12 > pageHeight - 30) {
      pdf.addPage();
      yPosition = 20;
    }
    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Error: Some raw parameters could not be displayed', margin, yPosition);
    yPosition += 10;
  }
  
  return yPosition;
}

/**
 * Utility function to pad a string to a specific length
 * 
 * @param value The string value to pad
 * @param length The desired length
 * @returns The padded string
 */
function padString(value: string, length: number): string {
  if (!value) return ''.padStart(length, ' ');
  return value.padStart(length, ' ');
}