// src/services/reports/pcsReport.ts
import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, BorderStyle, WidthType, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';
import jsPDF from 'jspdf';

/**
 * Generate both Word document and PDF reports for PCS checkout results
 * 
 * @param results The PCS test results
 * @returns A promise that resolves to the filename of the saved reports
 */
export async function generatePCSReport(results: any): Promise<string> {
  try {
    // Generate both Word and PDF reports
    const wordFilename = await generatePCSWordReport(results);
    const pdfFilename = await generatePCSPDFReport(results);
    
    return `${wordFilename} and ${pdfFilename}`;
  } catch (error) {
    console.error('‚ùå Error generating PCS reports:', error);
    throw new Error(`Failed to generate PCS reports: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a Word document report for PCS checkout results
 * 
 * @param results The PCS test results
 * @returns A promise that resolves to the filename of the saved report
 */
async function generatePCSWordReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `PCS_Checkout_${dateStr}_${timeStr}.docx`;
  
  console.log(`üìù Generating PCS Word report: ${filename}`);
  
  // Create the document
  const doc = new Document({
    sections: [{
      properties: {},
      children: [
        // Title
        new Paragraph({
          text: "PCS Automated Self Check Out Test Report",
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 200 }
        }),
        
        // Test metadata
        new Paragraph({
          text: `Test Version: 24.3.21`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Date: ${now.toLocaleDateString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Time: ${now.toLocaleTimeString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Generated by: SATS - Satellite Automated Testing System`,
          spacing: { after: 200 }
        }),
        
        // Test Summary
        new Paragraph({
          text: "Test Summary",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`,
          spacing: { after: 100 }
        }),
        
        // Separator
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Voltage Current On Summary section
        new Paragraph({
          text: "* Voltage Current On Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Voltage : ${formatFloat(results.on?.voltage || 'N/A')} V    ${results.on?.pass ? "[PASS]" : "[FAIL]"}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Current : ${formatFloat(results.on?.current || 'N/A')} A`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Firmware Version section
        new Paragraph({
          text: "* Firmware Version:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Current PCS Firmware Version    : ${results.firmware?.major || 'N/A'}.${results.firmware?.minor || 'N/A'}.${results.firmware?.patch || 'N/A'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Time Sync section
        new Paragraph({
          text: "* Time Sync:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `BEFORE update PCS Time  : ${results.timeSync?.before || 'N/A'} UTC`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `AFTER update PCS Time   : ${results.timeSync?.after || 'N/A'} UTC`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // PCS Checkout Summary section
        new Paragraph({
          text: "* PCS Checkout Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Time            : ${results.status?.time || 'N/A'} UTC`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Uptime          : ${results.status?.uptime || 'N/A'} sec`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS StorePeriod     : ${results.status?.storePeriod || 'N/A'} sec`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Uptime Session  : ${results.status?.uptimeSession || 'N/A'} sec`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Reset Count     : ${results.status?.resetCount || 'N/A'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Reset Source    : ${results.status?.resetSource || 'N/A'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "",
          spacing: { after: 100 }
        }),
        
        // Voltage Current Summary section
        new Paragraph({
          text: "* Voltage Current Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS PS 3V3 PCS1 I   : ${padString(results.vi?.ps3v3I || 'N/A', 4)} mA`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS PS 5 PCS1 I     : ${padString(results.vi?.ps5I || 'N/A', 4)} mA`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "",
          spacing: { after: 100 }
        }),
        
        // Memory Test Summary section
        new Paragraph({
          text: "* Memory Test Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Create memory test paragraphs
        ...createMemoryTestParagraphs(results),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // PCS Checkout Summary After Test section
        new Paragraph({
          text: "* PCS Checkout Summary After Test:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Time            : ${results.statusAfterTest?.time || 'N/A'} UTC`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Uptime          : ${results.statusAfterTest?.uptime || 'N/A'} sec`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS StorePeriod     : ${results.statusAfterTest?.storePeriod || 'N/A'} sec`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Uptime Session  : ${results.statusAfterTest?.uptimeSession || 'N/A'} sec`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Reset Count     : ${results.statusAfterTest?.resetCount || 'N/A'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Reset Source    : ${results.statusAfterTest?.resetSource || 'N/A'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Voltage Current Off Summary section
        new Paragraph({
          text: "* Voltage Current Off Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Voltage : ${formatFloat(results.off?.voltage || 'N/A')} V    ${results.off?.pass ? "[PASS]" : "[FAIL]"}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `PCS Current : ${formatFloat(results.off?.current || 'N/A')} A`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Test Completion Summary
        new Paragraph({
          text: "* Test Completion Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: results.error ? `Test completed with errors: ${results.error}` : "All tests completed successfully",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Report generated: ${now.toLocaleString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
      ]
    }]
  });
  
  try {
    // Generate the document
    console.log('üîÑ Generating PCS Word document...');
    const buffer = await Packer.toBuffer(doc);
    
    // Save the file using file-saver (this will save to the user's default Downloads folder)
    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
    saveAs(blob, filename);
    
    console.log(`‚úÖ PCS Word report saved successfully: ${filename}`);
    
    // Mark the report as generated
    if (results && typeof results === 'object') {
      results.reportGenerated = true;
    }
    
    return filename;
  } catch (error) {
    console.error('‚ùå Error generating PCS Word report:', error);
    throw new Error(`Failed to generate PCS Word report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a PDF report for PCS checkout results
 * 
 * @param results The PCS test results
 * @returns A promise that resolves to the filename of the saved PDF report
 */
async function generatePCSPDFReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `PCS_Checkout_${dateStr}_${timeStr}.pdf`;
  
  console.log(`üìù Generating PCS PDF report: ${filename}`);
  
  try {
    // Create new PDF document
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Set up the document
    let yPosition = 20;
    const pageWidth = pdf.internal.pageSize.width;
    const pageHeight = pdf.internal.pageSize.height;
    const margin = 20;
    const contentWidth = pageWidth - (2 * margin);

    // Helper function to check if we need a new page
    const checkNewPage = (requiredSpace: number = 20) => {
      if (yPosition + requiredSpace > pageHeight - 30) {
        pdf.addPage();
        yPosition = 20;
        return true;
      }
      return false;
    };

    // Title
    pdf.setFontSize(18);
    pdf.setFont('helvetica', 'bold');
    pdf.text('PCS Automated Self Check Out Test Report', margin, yPosition);
    yPosition += 15;

    // Subtitle
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Generated by SATS - Satellite Automated Testing System', margin, yPosition);
    yPosition += 10;

    // Test metadata
    pdf.setFontSize(10);
    pdf.text(`Test Date: ${now.toLocaleDateString()}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Test Time: ${now.toLocaleTimeString()}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`, margin, yPosition);
    yPosition += 15;

    // Add a separator line
    pdf.line(margin, yPosition, pageWidth - margin, yPosition);
    yPosition += 10;

    // Voltage Current On Summary Section
    checkNewPage(30);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Voltage Current On Summary', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.on) {
      pdf.text(`PCS Voltage: ${formatFloat(results.on.voltage || 'N/A')} V [${results.on.pass ? 'PASS' : 'FAIL'}]`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS Current: ${formatFloat(results.on.current || 'N/A')} A`, margin, yPosition);
    } else {
      pdf.text('ON voltage/current information not available', margin, yPosition);
    }
    yPosition += 15;

    // Firmware Version Section
    checkNewPage(30);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Firmware Version', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.firmware) {
      pdf.text(`Current PCS Firmware Version: ${results.firmware.major || 'N/A'}.${results.firmware.minor || 'N/A'}.${results.firmware.patch || 'N/A'}`, margin, yPosition);
    } else {
      pdf.text('Firmware information not available', margin, yPosition);
    }
    yPosition += 15;

    // Time Sync Section
    checkNewPage(30);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Time Sync', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.timeSync) {
      pdf.text(`BEFORE update PCS Time: ${results.timeSync.before || 'N/A'} UTC`, margin, yPosition);
      yPosition += 6;
      pdf.text(`AFTER update PCS Time: ${results.timeSync.after || 'N/A'} UTC`, margin, yPosition);
    } else {
      pdf.text('Time sync information not available', margin, yPosition);
    }
    yPosition += 15;

    // PCS Checkout Summary Section
    checkNewPage(50);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('PCS Checkout Summary', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.status) {
      const statusData = results.status;
      pdf.text(`PCS Time: ${statusData.time || 'N/A'} UTC`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS Uptime: ${statusData.uptime || 'N/A'} sec`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS StorePeriod: ${statusData.storePeriod || 'N/A'} sec`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS Uptime Session: ${statusData.uptimeSession || 'N/A'} sec`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS Reset Count: ${statusData.resetCount || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS Reset Source: ${statusData.resetSource || 'N/A'}`, margin, yPosition);
    } else {
      pdf.text('PCS status information not available', margin, yPosition);
    }
    yPosition += 15;

    // Voltage Current Summary Section
    checkNewPage(30);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Voltage Current Summary', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.vi) {
      const viData = results.vi;
      pdf.text(`PCS PS 3V3 PCS1 I: ${viData.ps3v3I || 'N/A'} mA`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS PS 5 PCS1 I: ${viData.ps5I || 'N/A'} mA`, margin, yPosition);
    } else {
      pdf.text('Voltage and current information not available', margin, yPosition);
    }
    yPosition += 15;

    // Memory Test Summary Section
    checkNewPage(60);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Memory Test Summary', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.sdCard && results.sdCard.enabled) {
      pdf.text(`SD Card: [${results.sdCard.pass ? 'PASS' : 'FAIL'}]`, margin, yPosition);
      yPosition += 8;
      
      pdf.text('Before Test:', margin, yPosition);
      yPosition += 6;
      pdf.text(`  Write Success: ${results.sdCard.before?.writeSuccess || 'N/A'}`, margin + 5, yPosition);
      yPosition += 6;
      pdf.text(`  Read Success: ${results.sdCard.before?.readSuccess || 'N/A'}`, margin + 5, yPosition);
      yPosition += 6;
      pdf.text(`  Write Fail: ${results.sdCard.before?.writeFail || 'N/A'}`, margin + 5, yPosition);
      yPosition += 6;
      pdf.text(`  Read Fail: ${results.sdCard.before?.readFail || 'N/A'}`, margin + 5, yPosition);
      yPosition += 8;
      
      pdf.text('After Test:', margin, yPosition);
      yPosition += 6;
      pdf.text(`  Write Success: ${results.sdCard.after?.writeSuccess || 'N/A'}`, margin + 5, yPosition);
      yPosition += 6;
      pdf.text(`  Read Success: ${results.sdCard.after?.readSuccess || 'N/A'}`, margin + 5, yPosition);
      yPosition += 6;
      pdf.text(`  Write Fail: ${results.sdCard.after?.writeFail || 'N/A'}`, margin + 5, yPosition);
      yPosition += 6;
      pdf.text(`  Read Fail: ${results.sdCard.after?.readFail || 'N/A'}`, margin + 5, yPosition);
    } else {
      pdf.text('SD Card test was not performed', margin, yPosition);
    }
    yPosition += 15;

    // PCS Checkout Summary After Test Section
    checkNewPage(50);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('PCS Checkout Summary After Test', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.statusAfterTest) {
      const statusData = results.statusAfterTest;
      pdf.text(`PCS Time: ${statusData.time || 'N/A'} UTC`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS Uptime: ${statusData.uptime || 'N/A'} sec`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS StorePeriod: ${statusData.storePeriod || 'N/A'} sec`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS Uptime Session: ${statusData.uptimeSession || 'N/A'} sec`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS Reset Count: ${statusData.resetCount || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS Reset Source: ${statusData.resetSource || 'N/A'}`, margin, yPosition);
    } else {
      pdf.text('PCS status after test information not available', margin, yPosition);
    }
    yPosition += 15;

    // Voltage Current Off Summary Section
    checkNewPage(30);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Voltage Current Off Summary', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.off) {
      pdf.text(`PCS Voltage: ${formatFloat(results.off.voltage || 'N/A')} V [${results.off.pass ? 'PASS' : 'FAIL'}]`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PCS Current: ${formatFloat(results.off.current || 'N/A')} A`, margin, yPosition);
    } else {
      pdf.text('OFF voltage/current information not available', margin, yPosition);
    }
    yPosition += 15;

    // Test Completion Summary
    checkNewPage(30);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Test Completion Summary', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text(results.error ? `Test completed with errors: ${results.error}` : "All tests completed successfully", margin, yPosition);
    yPosition += 6;
    pdf.text(`Report generated: ${now.toLocaleString()}`, margin, yPosition);

    // Add footer to all pages
    const totalPages = pdf.internal.pages.length - 1;
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 20, pageHeight - 10);
      pdf.text(`Generated: ${now.toLocaleString()}`, margin, pageHeight - 10);
    }

    // Save the PDF
    pdf.save(filename);

    console.log(`‚úÖ PCS PDF report saved successfully: ${filename}`);
    return filename;

  } catch (error) {
    console.error('‚ùå Error generating PCS PDF report:', error);
    throw new Error(`Failed to generate PCS PDF report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Helper function to create memory test paragraphs
function createMemoryTestParagraphs(results: any): Paragraph[] {
  if (!results.sdCard?.enabled) {
    return [new Paragraph('SD Card test was not performed')];
  }
  
  return [
    new Paragraph(`SD Card : -- ${results.sdCard.pass ? "[PASS]" : "[FAIL]"}`),
    new Paragraph(`Write Success before test   : ${padString(results.sdCard.before?.writeSuccess || 'N/A', 4)}`),
    new Paragraph(`Read Success before test    : ${padString(results.sdCard.before?.readSuccess || 'N/A', 4)}`),
    new Paragraph(`Write Fail before test      : ${padString(results.sdCard.before?.writeFail || 'N/A', 4)}`),
    new Paragraph(`Read Fail before test       : ${padString(results.sdCard.before?.readFail || 'N/A', 4)}`),
    new Paragraph(`Write Success after test    : ${padString(results.sdCard.after?.writeSuccess || 'N/A', 4)}`),
    new Paragraph(`Read Success after test     : ${padString(results.sdCard.after?.readSuccess || 'N/A', 4)}`),
    new Paragraph(`Write Fail after test       : ${padString(results.sdCard.after?.writeFail || 'N/A', 4)}`),
    new Paragraph(`Read Fail after test        : ${padString(results.sdCard.after?.readFail || 'N/A', 4)}`)
  ];
}

/**
 * Format a floating point value with 3 decimal places
 * 
 * @param value The value to format
 * @returns Formatted string with 3 decimal places
 */
function formatFloat(value: string): string {
  try {
    return parseFloat(value).toFixed(3);
  } catch (error) {
    return value;
  }
}

/**
 * Utility function to pad a string to a specific length
 * 
 * @param value The string value to pad
 * @param length The desired length
 * @returns The padded string
 */
function padString(value: string, length: number): string {
  if (!value) return ''.padStart(length, ' ');
  return value.toString().padStart(length, ' ');
}