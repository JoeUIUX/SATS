// src/services/reports/adcsReport.ts
import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, BorderStyle, WidthType, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';
import jsPDF from 'jspdf';

/**
 * Generate both Word document and PDF reports for ADCS checkout results
 * 
 * @param results The ADCS test results
 * @returns A promise that resolves to the filename of the saved reports
 */
export async function generateADCSReport(results: any): Promise<string> {
  try {
    // Generate both Word and PDF reports
    const wordFilename = await generateADCSWordReport(results);
    const pdfFilename = await generateADCSPDFReport(results);
    
    return `${wordFilename} and ${pdfFilename}`;
  } catch (error) {
    console.error('‚ùå Error generating ADCS reports:', error);
    throw new Error(`Failed to generate ADCS reports: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a Word document report for ADCS checkout results
 * 
 * @param results The ADCS test results
 * @returns A promise that resolves to the filename of the saved report
 */
async function generateADCSWordReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `ADCS_Checkout_${dateStr}_${timeStr}.docx`;
  
  console.log(`üìù Generating ADCS Word report: ${filename}`);
  
  // Create the document
  const doc = new Document({
    sections: [{
      properties: {},
      children: [
        // Title
        new Paragraph({
          text: "ADCS Automated Self Check Out Test Report",
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 200 }
        }),
        
        // Test metadata
        new Paragraph({
          text: `Test Version: 24.3.21`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Date: ${now.toLocaleDateString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Time: ${now.toLocaleTimeString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Generated by: SATS - Satellite Automated Testing System`,
          spacing: { after: 200 }
        }),
        
        // Test Summary
        new Paragraph({
          text: "Test Summary",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`,
          spacing: { after: 100 }
        }),
        
        // Separator
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Voltage Current Summary section
        new Paragraph({
          text: "* Voltage Current Summary :",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Initial power status
        new Paragraph({
          text: `ADCS Interface Voltage      : ${formatVoltage(results.vi?.adcsIfVoltage?.value)} V    ${formatStatus(results.vi?.adcsIfVoltage?.status)}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `ADCS Interface Current      : ${formatCurrent(results.vi?.adcsIfCurrent?.value)} A`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `ADCS Reaction Wheel Voltage : ${formatVoltage(results.vi?.adcsRwVoltage?.value)} V    ${formatStatus(results.vi?.adcsRwVoltage?.status)}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `ADCS Reaction Wheel Current : ${formatCurrent(results.vi?.adcsRwCurrent?.value)} A`,
          spacing: { after: 100 }
        }),
        
        // Separator
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // ADCS Command Status section
        new Paragraph({
          text: "* ADCS Command Status :",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Command status table
        ...(results.command ? [createCommandStatusTable(results)] : [new Paragraph({
          text: "Command status information not available",
          spacing: { after: 100 }
        })]),
        
        // Separator
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // ADCS Telemetry section
        new Paragraph({
          text: "* ADCS Telemetry :",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Command status
        new Paragraph({
          text: `TLM 128 : -- ${formatCommandStatus(results.command?.status)}`,
          spacing: { after: 100 }
        }),
        
        // Telemetry details (if available)
        new Paragraph({
          text: `Node type identifier        : ${results.telemetry?.identifier || "N/A"}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Program type identifier     : ${results.telemetry?.identifier || "N/A"}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Interface version           : ${results.telemetry?.interfaceVersion || "N/A"}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Firmware version (Major)    : ${results.telemetry?.fwVersionMajor || "N/A"}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Firmware version (Minor)    : ${results.telemetry?.fwVersionMinor || "N/A"}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Runtime (seconds)           : ${results.telemetry?.runtimeSec || "N/A"}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Runtime (milliseconds)      : ${results.telemetry?.runtimeMiliSec || "N/A"}`,
          spacing: { after: 100 }
        }),
        
        // Separator
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // Voltage Current Summary after power off section
        new Paragraph({
          text: "* Voltage Current Summary (After Power Off) :",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Power off status
        new Paragraph({
          text: `ADCS Interface Voltage      : ${formatVoltage(results.vi?.adcsIfVoltageOff?.value)} V    ${formatStatus(results.vi?.adcsIfVoltageOff?.status)}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `ADCS Interface Current      : ${formatCurrent(results.vi?.adcsIfCurrent?.value)} A`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `ADCS Reaction Wheel Voltage : ${formatVoltage(results.vi?.adcsRwVoltageOff?.value)} V    ${formatStatus(results.vi?.adcsRwVoltageOff?.status)}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `ADCS Reaction Wheel Current : ${formatCurrent(results.vi?.adcsRwCurrent?.value)} A`,
          spacing: { after: 100 }
        }),
        
        // Separator
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // Raw Parameters section
        new Paragraph({
          text: "* Raw Parameter Values :",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Raw parameters table
        ...(results.rawParameters ? [createRawParametersTable(results)] : [new Paragraph({
          text: "Raw parameter data not available",
          spacing: { after: 100 }
        })]),
        
        // Separator
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Test Completion Summary
        new Paragraph({
          text: "* Test Completion Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: results.error ? `Test completed with errors: ${results.error}` : "All tests completed successfully",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Report generated: ${now.toLocaleString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
      ]
    }]
  });
  
  try {
    // Generate the document
    console.log('üîÑ Generating ADCS Word document...');
    const buffer = await Packer.toBuffer(doc);
    
    // Save the file using file-saver (this will save to the user's default Downloads folder)
    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
    saveAs(blob, filename);
    
    console.log(`‚úÖ ADCS Word report saved successfully: ${filename}`);
    
    // Mark the report as generated
    if (results && typeof results === 'object') {
      results.reportGenerated = true;
    }
    
    return filename;
  } catch (error) {
    console.error('‚ùå Error generating ADCS Word report:', error);
    throw new Error(`Failed to generate ADCS Word report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a PDF report for ADCS checkout results
 * 
 * @param results The ADCS test results
 * @returns A promise that resolves to the filename of the saved PDF report
 */
async function generateADCSPDFReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `ADCS_Checkout_${dateStr}_${timeStr}.pdf`;
  
  console.log(`üìù Generating ADCS PDF report: ${filename}`);
  
  try {
    // Create new PDF document
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Set up the document
    let yPosition = 20;
    const pageWidth = pdf.internal.pageSize.width;
    const pageHeight = pdf.internal.pageSize.height;
    const margin = 20;
    const contentWidth = pageWidth - (2 * margin);

    // Helper function to check if we need a new page
    const checkNewPage = (requiredSpace: number = 20) => {
      if (yPosition + requiredSpace > pageHeight - 30) {
        pdf.addPage();
        yPosition = 20;
        return true;
      }
      return false;
    };

    // Helper function to add text with proper wrapping
    const addWrappedText = (text: string, x: number = margin, maxWidth: number = contentWidth) => {
      checkNewPage(8);
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      
      // Split text if it's too long
      const lines = pdf.splitTextToSize(text, maxWidth);
      
      if (Array.isArray(lines)) {
        lines.forEach((line: string) => {
          pdf.text(line, x, yPosition);
          yPosition += 6;
        });
      } else {
        pdf.text(lines, x, yPosition);
        yPosition += 6;
      }
    };

    // Title
    pdf.setFontSize(18);
    pdf.setFont('helvetica', 'bold');
    pdf.text('ADCS Automated Self Check Out Test Report', margin, yPosition);
    yPosition += 15;

    // Subtitle
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Generated by SATS - Satellite Automated Testing System', margin, yPosition);
    yPosition += 10;

    // Test metadata
    pdf.setFontSize(10);
    addWrappedText(`Test Date: ${now.toLocaleDateString()}`);
    addWrappedText(`Test Time: ${now.toLocaleTimeString()}`);
    addWrappedText(`Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`);
    addWrappedText(`Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`);
    yPosition += 10;

    // Add a separator line
    pdf.line(margin, yPosition, pageWidth - margin, yPosition);
    yPosition += 10;

    // Voltage Current Summary Section
    checkNewPage(60);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Voltage Current Summary', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.vi) {
      const viData = results.vi;
      addWrappedText(`ADCS Interface Voltage:      ${formatVoltage(viData.adcsIfVoltage?.value)} V    ${formatStatus(viData.adcsIfVoltage?.status)}`);
      addWrappedText(`ADCS Interface Current:      ${formatCurrent(viData.adcsIfCurrent?.value)} A`);
      addWrappedText(`ADCS Reaction Wheel Voltage: ${formatVoltage(viData.adcsRwVoltage?.value)} V    ${formatStatus(viData.adcsRwVoltage?.status)}`);
      addWrappedText(`ADCS Reaction Wheel Current: ${formatCurrent(viData.adcsRwCurrent?.value)} A`);
    } else {
      addWrappedText('Voltage and current information not available');
    }
    yPosition += 5;

    // Command Status Section
    checkNewPage(50);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('ADCS Command Status', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.command && results.commandResults) {
      addWrappedText(`Overall Command Status: ${formatCommandStatus(results.command.status)}`);
      yPosition += 2;
      
      const cmdResults = results.commandResults;
      if (cmdResults.length >= 8) {
        addWrappedText('Command Counters (Before -> After):');
        addWrappedText(`  TX Count:     ${cmdResults[0]} -> ${cmdResults[4]}`, margin + 5);
        addWrappedText(`  ACK Count:    ${cmdResults[1]} -> ${cmdResults[5]}`, margin + 5);
        addWrappedText(`  Timeout Count: ${cmdResults[2]} -> ${cmdResults[6]}`, margin + 5);
        addWrappedText(`  Error Count:   ${cmdResults[3]} -> ${cmdResults[7]}`, margin + 5);
      }
    } else {
      addWrappedText('Command status information not available');
    }
    yPosition += 5;

    // ADCS Telemetry Section
    checkNewPage(60);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('ADCS Telemetry', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.command) {
      addWrappedText(`TLM 128: -- ${formatCommandStatus(results.command.status)}`);
      yPosition += 2;
    }

    if (results.telemetry) {
      const telemetryData = results.telemetry;
      addWrappedText(`Node type identifier:        ${telemetryData.identifier || 'N/A'}`);
      addWrappedText(`Program type identifier:     ${telemetryData.identifier || 'N/A'}`);
      addWrappedText(`Interface version:           ${telemetryData.interfaceVersion || 'N/A'}`);
      addWrappedText(`Firmware version (Major):    ${telemetryData.fwVersionMajor || 'N/A'}`);
      addWrappedText(`Firmware version (Minor):    ${telemetryData.fwVersionMinor || 'N/A'}`);
      addWrappedText(`Runtime (seconds):           ${telemetryData.runtimeSec || 'N/A'}`);
      addWrappedText(`Runtime (milliseconds):      ${telemetryData.runtimeMiliSec || 'N/A'}`);
    } else {
      addWrappedText('Telemetry information not available');
    }
    yPosition += 5;

    // Voltage Current Summary After Power Off Section
    checkNewPage(50);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Voltage Current Summary (After Power Off)', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.vi) {
      const viData = results.vi;
      addWrappedText(`ADCS Interface Voltage:      ${formatVoltage(viData.adcsIfVoltageOff?.value)} V    ${formatStatus(viData.adcsIfVoltageOff?.status)}`);
      addWrappedText(`ADCS Interface Current:      ${formatCurrent(viData.adcsIfCurrent?.value)} A`);
      addWrappedText(`ADCS Reaction Wheel Voltage: ${formatVoltage(viData.adcsRwVoltageOff?.value)} V    ${formatStatus(viData.adcsRwVoltageOff?.status)}`);
      addWrappedText(`ADCS Reaction Wheel Current: ${formatCurrent(viData.adcsRwCurrent?.value)} A`);
    } else {
      addWrappedText('Power off voltage and current information not available');
    }
    yPosition += 10;

    // Raw Parameters Section
    checkNewPage(80);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Raw Parameter Values', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.rawParameters) {
      addWrappedText('Voltage & Current Parameters:');
      yPosition += 2;
      
      const adcsVi = ["HEPS1_PDM2_ADCS_IF_V", "HEPS1_PDM2_ADCS-IF_I", "HEPS1_PDM2_ADCS_RW_V", "HEPS1_PDM2_ADCS_RW_I"];
      adcsVi.forEach(param => {
        if (results.rawParameters[param] !== undefined) {
          addWrappedText(`  ${param}: ${results.rawParameters[param]}`, margin + 5, contentWidth - 10);
        }
      });
      
      yPosition += 3;
      checkNewPage(40);
      addWrappedText('Telemetry Parameters:');
      yPosition += 2;
      
      const adcsTlm128 = [
        "ADCS1_TLM_Identifier", "ADCS1_TLM_InterfaceVer", "ADCS1_TLM_IdFwVerMajor", "ADCS1_TLM_IdFwVerMinor",
        "ADCS1_TLM_RuntimeSec", "ADCS1_TLM_RuntimeMiliSec"
      ];
      adcsTlm128.forEach(param => {
        if (results.rawParameters[param] !== undefined) {
          addWrappedText(`  ${param}: ${results.rawParameters[param]}`, margin + 5, contentWidth - 10);
        }
      });
      
      yPosition += 3;
      checkNewPage(40);
      addWrappedText('Command Status Parameters (Before):');
      yPosition += 2;
      
      const adcsStat = ["OBC1_Itc_Adcs_Tm_TxCount", "OBC1_Itc_Adcs_Tm_AckCount", "OBC1_Itc_Adcs_Tm_TimeoutCount", "OBC1_Itc_Adcs_Tm_ErrCount"];
      adcsStat.forEach(param => {
        if (results.rawParameters[`${param}_before`] !== undefined) {
          addWrappedText(`  ${param}_before: ${results.rawParameters[`${param}_before`]}`, margin + 5, contentWidth - 10);
        }
      });
      
      yPosition += 3;
      addWrappedText('Command Status Parameters (After):');
      yPosition += 2;
      
      adcsStat.forEach(param => {
        if (results.rawParameters[`${param}_after`] !== undefined) {
          addWrappedText(`  ${param}_after: ${results.rawParameters[`${param}_after`]}`, margin + 5, contentWidth - 10);
        }
      });
      
      yPosition += 3;
      addWrappedText('Power Control Parameters:');
      yPosition += 2;
      
      const powerParams = ["OBC1_Ch_ExtReqOn_1", "OBC1_Ch_ExtReqOn_2", "OBC1_Ch_ExtReqOff_1", "OBC1_Ch_ExtReqOff_2", "OBC1_Adcs_TlmID", "OBC1_Adcs_Control"];
      powerParams.forEach(param => {
        if (results.rawParameters[param] !== undefined) {
          addWrappedText(`  ${param}: ${results.rawParameters[param]}`, margin + 5, contentWidth - 10);
        }
      });
    } else {
      addWrappedText('Raw parameter data not available');
    }
    yPosition += 10;

    // Test Completion Summary
    checkNewPage(30);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Test Completion Summary', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    addWrappedText(results.error ? `Test completed with errors: ${results.error}` : 'All tests completed successfully');
    addWrappedText(`Report generated: ${now.toLocaleString()}`);

    // Add footer to all pages
    const totalPages = pdf.internal.pages.length - 1;
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 20, pageHeight - 10);
      pdf.text(`Generated: ${now.toLocaleString()}`, margin, pageHeight - 10);
    }

    // Save the PDF
    pdf.save(filename);

    console.log(`‚úÖ ADCS PDF report saved successfully: ${filename}`);
    return filename;

  } catch (error) {
    console.error('‚ùå Error generating ADCS PDF report:', error);
    throw new Error(`Failed to generate ADCS PDF report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Helper function to create command status table for Word document
 */
function createCommandStatusTable(results: any): Table {
  const cmdResults = results.commandResults || [];
  
  if (cmdResults.length < 8) {
    return new Table({
      rows: [
        new TableRow({
          children: [
            new TableCell({
              children: [new Paragraph('Command status data incomplete')],
              width: { size: 100, type: WidthType.PERCENTAGE }
            })
          ]
        })
      ],
      width: { size: 100, type: WidthType.PERCENTAGE }
    });
  }
  
  const rows = [
    ['Counter Type', 'Before Command', 'After Command', 'Difference'],
    ['TX Count', cmdResults[0] || 'N/A', cmdResults[4] || 'N/A', String((parseInt(cmdResults[4] || '0') - parseInt(cmdResults[0] || '0')) || 0)],
    ['ACK Count', cmdResults[1] || 'N/A', cmdResults[5] || 'N/A', String((parseInt(cmdResults[5] || '0') - parseInt(cmdResults[1] || '0')) || 0)],
    ['Timeout Count', cmdResults[2] || 'N/A', cmdResults[6] || 'N/A', String((parseInt(cmdResults[6] || '0') - parseInt(cmdResults[2] || '0')) || 0)],
    ['Error Count', cmdResults[3] || 'N/A', cmdResults[7] || 'N/A', String((parseInt(cmdResults[7] || '0') - parseInt(cmdResults[3] || '0')) || 0)],
    ['Overall Status', '', '', formatCommandStatus(results.command?.status)]
  ].map((row, index) => new TableRow({
    children: row.map(cell => new TableCell({
      children: [new Paragraph({
        text: cell,
        run: index === 0 ? { bold: true } : undefined // Make header row bold
      })],
      width: { size: 25, type: WidthType.PERCENTAGE }
    }))
  }));

  return new Table({
    rows,
    width: { size: 100, type: WidthType.PERCENTAGE },
    borders: {
      top: { style: BorderStyle.SINGLE, size: 1 },
      bottom: { style: BorderStyle.SINGLE, size: 1 },
      left: { style: BorderStyle.SINGLE, size: 1 },
      right: { style: BorderStyle.SINGLE, size: 1 },
      insideHorizontal: { style: BorderStyle.SINGLE, size: 1 },
      insideVertical: { style: BorderStyle.SINGLE, size: 1 }
    }
  });
}

/**
 * Helper function to create raw parameters table for Word document
 */
function createRawParametersTable(results: any): Table {
  const rawParams = results.rawParameters || {};
  
  // Define parameter groups
  const parameterGroups = [
    {
      title: 'Voltage & Current Parameters',
      params: ["HEPS1_PDM2_ADCS_IF_V", "HEPS1_PDM2_ADCS-IF_I", "HEPS1_PDM2_ADCS_RW_V", "HEPS1_PDM2_ADCS_RW_I"]
    },
    {
      title: 'Telemetry Parameters',
      params: ["ADCS1_TLM_Identifier", "ADCS1_TLM_InterfaceVer", "ADCS1_TLM_IdFwVerMajor", "ADCS1_TLM_IdFwVerMinor", "ADCS1_TLM_RuntimeSec", "ADCS1_TLM_RuntimeMiliSec"]
    },
    {
      title: 'Command Status Parameters',
      params: ["OBC1_Itc_Adcs_Tm_TxCount", "OBC1_Itc_Adcs_Tm_AckCount", "OBC1_Itc_Adcs_Tm_TimeoutCount", "OBC1_Itc_Adcs_Tm_ErrCount"]
    }
  ];
  
  const tableRows: TableRow[] = [];
  
  // Add header row
  tableRows.push(new TableRow({
    children: [
      new TableCell({
        children: [new Paragraph({ text: 'Parameter', run: { bold: true } })],
        width: { size: 70, type: WidthType.PERCENTAGE }
      }),
      new TableCell({
        children: [new Paragraph({ text: 'Value', run: { bold: true } })],
        width: { size: 30, type: WidthType.PERCENTAGE }
      })
    ]
  }));
  
  // Add parameters by group
  parameterGroups.forEach(group => {
    // Add group header
    tableRows.push(new TableRow({
      children: [
        new TableCell({
          children: [new Paragraph({ text: group.title, run: { bold: true, italics: true } })],
          columnSpan: 2
        })
      ]
    }));
    
// Add parameters in this group
    group.params.forEach(param => {
      tableRows.push(new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph(param)],
            width: { size: 70, type: WidthType.PERCENTAGE }
          }),
          new TableCell({
            children: [new Paragraph(rawParams[param] || 'N/A')],
            width: { size: 30, type: WidthType.PERCENTAGE }
          })
        ]
      }));
    });
  });

  return new Table({
    rows: tableRows,
    width: { size: 100, type: WidthType.PERCENTAGE },
    borders: {
      top: { style: BorderStyle.SINGLE, size: 1 },
      bottom: { style: BorderStyle.SINGLE, size: 1 },
      left: { style: BorderStyle.SINGLE, size: 1 },
      right: { style: BorderStyle.SINGLE, size: 1 },
      insideHorizontal: { style: BorderStyle.SINGLE, size: 1 },
      insideVertical: { style: BorderStyle.SINGLE, size: 1 }
    }
  });
}

/**
 * Format voltage value to display with proper precision
 * @param value Voltage value as string
 * @returns Formatted voltage string
 */
function formatVoltage(value: string | undefined): string {
  if (!value) return "0.000";
  try {
    const voltage = parseFloat(value);
    return voltage.toFixed(3).padStart(6, ' ');
  } catch (error) {
    return value || "0.000";
  }
}

/**
 * Format current value to display with proper precision
 * @param value Current value as string
 * @returns Formatted current string
 */
function formatCurrent(value: string | undefined): string {
  if (!value) return "0.000";
  try {
    const current = parseFloat(value);
    return current.toFixed(3).padStart(6, ' ');
  } catch (error) {
    return value || "0.000";
  }
}

/**
 * Format status string for display in report
 * @param status Status string
 * @returns Formatted status for report
 */
function formatStatus(status: string | undefined): string {
  if (!status) return "[N/A]";
  switch (status) {
    case "PASS":
      return "[PASS]";
    case "FAIL":
      return "[FAIL]";
    case "ERROR":
      return "[ERROR]";
    default:
      return `[${status}]`;
  }
}

/**
 * Format command execution status for display in report
 * @param status Command status
 * @returns Formatted command status for report
 */
function formatCommandStatus(status: string | undefined): string {
  if (!status) return "[N/A]";
  switch (status) {
    case "PASS":
      return "[PASS]";
    case "PASS_TIMEOUT":
      return "[PASS] - with timeout";
    case "FAIL_NO_REPLY":
      return "[FAIL] - No reply";
    case "FAIL_CMD_NOT_SENT":
      return "[FAIL] - Command not sent";
    case "ERROR":
      return "[ERROR]";
    default:
      return `[${status}]`;
  }
}