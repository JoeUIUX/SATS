// src/services/reports/uhfReport.ts
import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, BorderStyle, WidthType, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';
import jsPDF from 'jspdf';

/**
 * Generate both Word document and PDF reports for UHF checkout results
 * 
 * @param results The UHF test results
 * @returns A promise that resolves to the filename of the saved reports
 */
export async function generateUHFReport(results: any): Promise<string> {
  try {
    // Generate both Word and PDF reports
    const wordFilename = await generateUHFWordReport(results);
    const pdfFilename = await generateUHFPDFReport(results);
    
    return `${wordFilename} and ${pdfFilename}`;
  } catch (error) {
    console.error('‚ùå Error generating UHF reports:', error);
    throw new Error(`Failed to generate UHF reports: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a Word document report for UHF checkout results
 * 
 * @param results The UHF test results
 * @returns A promise that resolves to the filename of the saved report
 */
async function generateUHFWordReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `UHF_Checkout_${dateStr}_${timeStr}.docx`;
  
  console.log(`üìù Generating UHF Word report: ${filename}`);
  
  // Create the document
  const doc = new Document({
    sections: [{
      properties: {},
      children: [
        // Title
        new Paragraph({
          text: "UHF Automated Self Check Out Test Report",
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 200 }
        }),
        
        // Test metadata
        new Paragraph({
          text: `Test Version: 24.3.21`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Date: ${now.toLocaleDateString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Time: ${now.toLocaleTimeString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Generated by: SATS - Satellite Automated Testing System`,
          spacing: { after: 200 }
        }),
        
        // Test Summary
        new Paragraph({
          text: "Test Summary",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`,
          spacing: { after: 100 }
        }),
        
        // Separator
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // UHF Telemetry section
        new Paragraph({
          text: "* UHF Telemetry:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        ...createTelemetrySection(results),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // UHF System Configuration section
        new Paragraph({
          text: "* UHF System Configuration:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        ...createSystemSection(results),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // UHF Receiver Configuration section
        new Paragraph({
          text: "* UHF Receiver Configuration:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        ...createReceiverSection(results),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // UHF Transmitter Configuration section
        new Paragraph({
          text: "* UHF Transmitter Configuration:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        ...createTransmitterSection(results),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Test Completion Summary
        new Paragraph({
          text: "* Test Completion Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: results.error ? `Test completed with errors: ${results.error}` : "All tests completed successfully",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Report generated: ${now.toLocaleString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
      ]
    }]
  });
  
  try {
    // Generate the document
    console.log('üîÑ Generating UHF Word document...');
    const buffer = await Packer.toBuffer(doc);
    
    // Save the file using file-saver (this will save to the user's default Downloads folder)
    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
    saveAs(blob, filename);
    
    console.log(`‚úÖ UHF Word report saved successfully: ${filename}`);
    
    // Mark the report as generated
    if (results && typeof results === 'object') {
      results.reportGenerated = true;
    }
    
    return filename;
  } catch (error) {
    console.error('‚ùå Error generating UHF Word report:', error);
    throw new Error(`Failed to generate UHF Word report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a PDF report for UHF checkout results
 * 
 * @param results The UHF test results
 * @returns A promise that resolves to the filename of the saved PDF report
 */
async function generateUHFPDFReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `UHF_Checkout_${dateStr}_${timeStr}.pdf`;
  
  console.log(`üìù Generating UHF PDF report: ${filename}`);
  
  try {
    // Create new PDF document
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Set up the document
    let yPosition = 20;
    const pageWidth = pdf.internal.pageSize.width;
    const pageHeight = pdf.internal.pageSize.height;
    const margin = 20;
    const contentWidth = pageWidth - (2 * margin);

    // Helper function to check if we need a new page
    const checkNewPage = (requiredSpace: number = 20) => {
      if (yPosition + requiredSpace > pageHeight - 30) {
        pdf.addPage();
        yPosition = 20;
        return true;
      }
      return false;
    };

    // Helper function to add text with wrapping
    const addWrappedText = (text: string, x: number, y: number, maxWidth: number, fontSize: number = 10) => {
      pdf.setFontSize(fontSize);
      const splitText = pdf.splitTextToSize(text, maxWidth);
      pdf.text(splitText, x, y);
      return splitText.length * (fontSize * 0.352777778); // Approximate line height in mm
    };

    // Title
    pdf.setFontSize(18);
    pdf.setFont('helvetica', 'bold');
    pdf.text('UHF Automated Self Check Out Test Report', margin, yPosition);
    yPosition += 15;

    // Subtitle
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Generated by SATS - Satellite Automated Testing System', margin, yPosition);
    yPosition += 10;

    // Test metadata
    pdf.setFontSize(10);
    pdf.text(`Test Date: ${now.toLocaleDateString()}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Test Time: ${now.toLocaleTimeString()}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`, margin, yPosition);
    yPosition += 15;

    // Add a separator line
    pdf.line(margin, yPosition, pageWidth - margin, yPosition);
    yPosition += 10;

    // UHF Telemetry Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('UHF Telemetry', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.telemetry) {
      const telemetry = results.telemetry;
      const telemetryData = [
        [`Board temperature (near MCU)`, `${telemetry.boardTemperature || 'N/A'} degree C`],
        [`PA temperature (near PA)`, `${telemetry.paTemperature || 'N/A'} degree C`],
        [`Last received RSSI`, `${telemetry.lastRssi || 'N/A'}`],
        [`Last received RF error`, `${telemetry.lastRferr || 'N/A'}`],
        [`Number of tx packets since reboot`, `${telemetry.txCount || 'N/A'} packets`],
        [`Number of rx packets since reboot`, `${telemetry.rxCount || 'N/A'} packets`],
        [`Number of tx bytes since reboot`, `${telemetry.txBytes || 'N/A'} bytes`],
        [`Number of rx bytes since reboot`, `${telemetry.rxBytes || 'N/A'} bytes`],
        [`Currently active system configuration`, `${telemetry.activeConf || 'N/A'}`],
        [`Number of reboots`, `${telemetry.bootCount || 'N/A'}`],
        [`Cause of the reboot`, `${telemetry.bootCause || 'N/A'}`],
        [`Timestamp of last valid packet`, `${telemetry.lastContact || 'N/A'}`],
        [`Current background RSSI level`, `${telemetry.bgndRssi || 'N/A'}`],
        [`Total TX duty time since reboot`, `${telemetry.txDuty || 'N/A'}`],
        [`Number of tx packets (total)`, `${telemetry.totalTxCount || 'N/A'} packets`],
        [`Number of rx packets (total)`, `${telemetry.totalRxCount || 'N/A'} packets`],
        [`Number of tx bytes (total)`, `${telemetry.totalTxBytes || 'N/A'} bytes`],
        [`Number of rx bytes (total)`, `${telemetry.totalRxBytes || 'N/A'} bytes`]
      ];

      for (const [label, value] of telemetryData) {
        checkNewPage(8);
        pdf.text(`${label.padEnd(45, ' ')}: ${value}`, margin, yPosition);
        yPosition += 6;
      }
    } else {
      pdf.text('Telemetry information not available', margin, yPosition);
      yPosition += 6;
    }
    yPosition += 10;

    // UHF System Configuration Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('UHF System Configuration', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.system) {
      const system = results.system;
      const systemData = [
        [`RSSI indicator offset`, `${system.rssiOffset || 'N/A'}`],
        [`Maximum temperature`, `${system.maxTemp || 'N/A'} degree C`],
        [`Exponential moving average (alpha)`, `${system.bgndrssiEma || 'N/A'}`],
        [`CSP address of the AX100 module`, `${system.cspNode || 'N/A'}`],
        [`Enables I2C`, `${system.i2cEn || 'N/A'}`],
        [`Enables CAN`, `${system.canEn || 'N/A'}`],
        [`Enables push-to-talk driver`, `${system.extpptEn || 'N/A'}`],
        [`On-board LEDs enabled`, `${system.ledEn || 'N/A'}`],
        [`USART for KISS interface`, `${system.kissUsart || 'N/A'}`],
        [`USART for GOSH interface`, `${system.goshUsart || 'N/A'}`],
        [`Non-shifted I2C address`, `${system.i2cAddr || 'N/A'}`],
        [`I2C master speed`, `${system.i2cKhz || 'N/A'}`],
        [`CAN bus speed`, `${system.canKhz || 'N/A'}`],
        [`Seconds before automatic reboot`, `${system.rebootIn || 'N/A'}`],
        [`Transmitter shutdown seconds`, `${system.txInhibit || 'N/A'}`],
        [`Log-system FRAM storage enabled`, `${system.logStore || 'N/A'}`],
        [`TX power level`, `${system.txPwr || 'N/A'}`],
        [`Maximum TX time`, `${system.maxTxTime || 'N/A'} seconds`],
        [`Maximum idle time`, `${system.maxIdleTime || 'N/A'} seconds`]
      ];

      for (const [label, value] of systemData) {
        checkNewPage(8);
        pdf.text(`${label.padEnd(45, ' ')}: ${value}`, margin, yPosition);
        yPosition += 6;
      }
    } else {
      pdf.text('System configuration information not available', margin, yPosition);
      yPosition += 6;
    }
    yPosition += 10;

    // UHF Receiver Configuration Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('UHF Receiver Configuration', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.receiver) {
      const receiver = results.receiver;
      const receiverData = [
        [`Frequency`, `${receiver.frequency || 'N/A'} Hz`],
        [`Baudrate`, `${receiver.baudrate || 'N/A'} bps`],
        [`Modulation index`, `${receiver.modindex || 'N/A'}`],
        [`RX guard`, `${receiver.guard || 'N/A'} ms`],
        [`PLLRANGE register startup value`, `${receiver.pllrang || 'N/A'}`],
        [`Framing mode`, `${receiver.mode || 'N/A'}`],
        [`HMAC enabled`, `${receiver.cspHmac || 'N/A'}`],
        [`Reed-Solomon enabled`, `${receiver.cspRs || 'N/A'}`],
        [`CRC-32 enabled`, `${receiver.cspCrc || 'N/A'}`],
        [`CCSDS randomization enabled`, `${receiver.cspRand || 'N/A'}`],
        [`HMAC key`, `${receiver.hmacKeys?.[0] || 'N/A'}${receiver.hmacKeys?.[1] || ''}`],
        [`Call sign`, `${receiver.ax25Call?.[0] || 'N/A'}${receiver.ax25Call?.[1] || ''}`],
        [`Receiver bandwidth`, `${receiver.bandwidth || 'N/A'} Hz`],
        [`AFC pull-in range`, `${receiver.afcrange || 'N/A'} Hz`]
      ];

      for (const [label, value] of receiverData) {
        checkNewPage(8);
        pdf.text(`${label.padEnd(45, ' ')}: ${value}`, margin, yPosition);
        yPosition += 6;
      }
    } else {
      pdf.text('Receiver configuration information not available', margin, yPosition);
      yPosition += 6;
    }
    yPosition += 10;

    // UHF Transmitter Configuration Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('UHF Transmitter Configuration', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.transmitter) {
      const transmitter = results.transmitter;
      const transmitterData = [
        [`Frequency`, `${transmitter.frequency || 'N/A'} Hz`],
        [`Baudrate`, `${transmitter.baudrate || 'N/A'} bps`],
        [`Modulation index`, `${transmitter.modindex || 'N/A'}`],
        [`RX guard`, `${transmitter.guard || 'N/A'} ms`],
        [`PLLRANGE register startup value`, `${transmitter.pllrang || 'N/A'}`],
        [`Framing mode`, `${transmitter.mode || 'N/A'}`],
        [`HMAC enabled`, `${transmitter.cspHmac || 'N/A'}`],
        [`Reed-Solomon enabled`, `${transmitter.cspRs || 'N/A'}`],
        [`CRC-32 enabled`, `${transmitter.cspCrc || 'N/A'}`],
        [`CCSDS randomization enabled`, `${transmitter.cspRand || 'N/A'}`],
        [`HMAC key`, `${transmitter.hmacKeys?.[0] || 'N/A'}${transmitter.hmacKeys?.[1] || ''}`],
        [`Call sign`, `${transmitter.ax25Call?.[0] || 'N/A'}${transmitter.ax25Call?.[1] || ''}`],
        [`Preamble byte`, `${transmitter.preamb || 'N/A'}`],
        [`Preamble length`, `${transmitter.preamblen || 'N/A'} bytes`],
        [`Preamble flags`, `${transmitter.preambflags || 'N/A'}`],
        [`Inter-frame byte`, `${transmitter.intfrm || 'N/A'}`],
        [`Inter-frame length`, `${transmitter.intfrmlen || 'N/A'} bytes`],
        [`Inter-frame flags`, `${transmitter.intfrmflags || 'N/A'}`],
        [`RSSI busy threshold`, `${transmitter.rssibusy || 'N/A'}`],
        [`Key-up delay`, `${transmitter.kupDelay || 'N/A'}`],
        [`PA input level`, `${transmitter.paLevel || 'N/A'}`],
        [`Bit error rate injection`, `${transmitter.ber || 'N/A'}`]
      ];

      for (const [label, value] of transmitterData) {
        checkNewPage(8);
        pdf.text(`${label.padEnd(45, ' ')}: ${value}`, margin, yPosition);
        yPosition += 6;
      }
    } else {
      pdf.text('Transmitter configuration information not available', margin, yPosition);
      yPosition += 6;
    }
    yPosition += 15;

    // Test Completion Summary
    checkNewPage(20);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Test Completion Summary', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    pdf.text(results.error ? `Test completed with errors: ${results.error}` : "All tests completed successfully", margin, yPosition);
    yPosition += 6;
    pdf.text(`Report generated: ${now.toLocaleString()}`, margin, yPosition);

    // Add footer to all pages
    const totalPages = pdf.internal.pages.length - 1;
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 20, pageHeight - 10);
      pdf.text(`Generated: ${now.toLocaleString()}`, margin, pageHeight - 10);
    }

    // Save the PDF
    pdf.save(filename);

    console.log(`‚úÖ UHF PDF report saved successfully: ${filename}`);
    return filename;

  } catch (error) {
    console.error('‚ùå Error generating UHF PDF report:', error);
    throw new Error(`Failed to generate UHF PDF report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Helper function for the telemetry section
function createTelemetrySection(results: any): Paragraph[] {
  const telemetry = results.telemetry || {};
  return [
    new Paragraph({
      text: `Board temperature (near MCU)                : ${telemetry.boardTemperature || 'N/A'} degree C`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `PA temperature (near PA)                    : ${telemetry.paTemperature || 'N/A'} degree C`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Last received RSSI                          : ${telemetry.lastRssi || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Last received RF error                      : ${telemetry.lastRferr || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Number of tx packets since reboot           : ${telemetry.txCount || 'N/A'} packets`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Number of rx packets since reboot           : ${telemetry.rxCount || 'N/A'} packets`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Number of tx bytes since reboot             : ${telemetry.txBytes || 'N/A'} bytes`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Number of rx bytes since reboot             : ${telemetry.rxBytes || 'N/A'} bytes`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The currently active system configuration   : ${telemetry.activeConf || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The number of reboots                       : ${telemetry.bootCount || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The cause of the reboot                     : ${telemetry.bootCause || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The timestamp of the last valid packet      : ${telemetry.lastContact || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The current background RSSI level           : ${telemetry.bgndRssi || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Total TX duty time since reboot             : ${telemetry.txDuty || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Number of tx packets (total)                : ${telemetry.totalTxCount || 'N/A'} packets`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Number of rx packets (total)                : ${telemetry.totalRxCount || 'N/A'} packets`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Number of tx bytes (total)                  : ${telemetry.totalTxBytes || 'N/A'} bytes`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Number of rx bytes (total)                  : ${telemetry.totalRxBytes || 'N/A'} bytes`,
      spacing: { after: 100 }
    })
  ];
}

// Helper function for the system configuration section
function createSystemSection(results: any): Paragraph[] {
  const system = results.system || {};
  return [
    new Paragraph({
      text: `Sets the RSSI indicator offset              : ${system.rssiOffset || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Maximum temperature                         : ${system.maxTemp || 'N/A'} degree C`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Exponential moving average (alpha value)    : ${system.bgndrssiEma || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `CSP address of the AX100 module             : ${system.cspNode || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enables I2C                                 : ${system.i2cEn || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enables CAN                                 : ${system.canEn || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enables push-to-talk driver (GS100 only)    : ${system.extpptEn || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Set to zero to disable the on-board leds    : ${system.ledEn || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Set which USART to use for KISS interface   : ${system.kissUsart || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Set which USART to use for GOSH interface   : ${system.goshUsart || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The non-shifted I2C address of the system   : ${system.i2cAddr || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The speed of the I2C master                 : ${system.i2cKhz || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The speed of the CAN bus                    : ${system.canKhz || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Number of seconds before automatic reboot   : ${system.rebootIn || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Number of seconds the transmitter shutdown  : ${system.txInhibit || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enable log-system FRAM storage backend      : ${system.logStore || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `TX power level                              : ${system.txPwr || 'N/A'}`,
      spacing: { after: 100 }
}),
    new Paragraph({
      text: `Maximum seconds to key up the transmitter   : ${system.maxTxTime || 'N/A'} seconds`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Number of seconds the receiver can be idle  : ${system.maxIdleTime || 'N/A'} seconds`,
      spacing: { after: 100 }
    })
  ];
}

// Helper function for the receiver configuration section
function createReceiverSection(results: any): Paragraph[] {
  const receiver = results.receiver || {};
  return [
    new Paragraph({
      text: `Frequency in [Hz]                           : ${receiver.frequency || 'N/A'} Hz`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Baudrate                                    : ${receiver.baudrate || 'N/A'} bps`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Same as the tx_modindex                     : ${receiver.modindex || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `RX guard in [ms]                            : ${receiver.guard || 'N/A'} ms`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Startup value of the PLLRANGE register      : ${receiver.pllrang || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Framing mode                                : ${receiver.mode || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enable HMAC (checksum and authentication)   : ${receiver.cspHmac || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enable Reed-Solomon                         : ${receiver.cspRs || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enable CRC-32                               : ${receiver.cspCrc || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enable CCSDS randomization                  : ${receiver.cspRand || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `HMAC key (needs to match transmitter)       : ${receiver.hmacKeys?.[0] || 'N/A'}${receiver.hmacKeys?.[1] || ''}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The call sign                               : ${receiver.ax25Call?.[0] || 'N/A'}${receiver.ax25Call?.[1] || ''}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Receiver bandwidth in Hz                    : ${receiver.bandwidth || 'N/A'} Hz`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Sets the AFC pull-in range in Hz            : ${receiver.afcrange || 'N/A'} Hz`,
      spacing: { after: 100 }
    })
  ];
}

// Helper function for the transmitter configuration section
function createTransmitterSection(results: any): Paragraph[] {
  const transmitter = results.transmitter || {};
  return [
    new Paragraph({
      text: `Frequency in [Hz]                           : ${transmitter.frequency || 'N/A'} Hz`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Baudrate                                    : ${transmitter.baudrate || 'N/A'} bps`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Same as the tx_modindex                     : ${transmitter.modindex || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `RX guard in [ms]                            : ${transmitter.guard || 'N/A'} ms`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Startup value of the PLLRANGE register      : ${transmitter.pllrang || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Framing mode                                : ${transmitter.mode || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enable HMAC (checksum and authentication)   : ${transmitter.cspHmac || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enable Reed-Solomon                         : ${transmitter.cspRs || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enable CRC-32                               : ${transmitter.cspCrc || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Enable CCSDS randomization                  : ${transmitter.cspRand || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `HMAC key (needs to match transmitter)       : ${transmitter.hmacKeys?.[0] || 'N/A'}${transmitter.hmacKeys?.[1] || ''}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The call sign                               : ${transmitter.ax25Call?.[0] || 'N/A'}${transmitter.ax25Call?.[1] || ''}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The byte to use as preamble                 : ${transmitter.preamb || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The length of the preamble in bytes         : ${transmitter.preamblen || 'N/A'} bytes`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The flags to use for the preamble           : ${transmitter.preambflags || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The byte to use between two frames          : ${transmitter.intfrm || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The number of bytes put between two frames  : ${transmitter.intfrmlen || 'N/A'} bytes`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The flags to use for the intfrm bytes       : ${transmitter.intfrmflags || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Busy when the RSSI is above this value      : ${transmitter.rssibusy || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `An additional delay of the first frame      : ${transmitter.kupDelay || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `The input level for the PA                  : ${transmitter.paLevel || 'N/A'}`,
      spacing: { after: 100 }
    }),
    new Paragraph({
      text: `Injects random bit-errors                   : ${transmitter.ber || 'N/A'}`,
      spacing: { after: 100 }
    })
  ];
}