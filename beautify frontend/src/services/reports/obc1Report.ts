// src/services/reports/obc1Report.ts
import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, BorderStyle, WidthType, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';
import jsPDF from 'jspdf';

/**
 * Generate both Word document and PDF reports for OBC-1 checkout results
 * 
 * @param results The OBC-1 test results
 * @returns A promise that resolves to the filename of the saved reports
 */
export async function generateOBC1Report(results: any): Promise<string> {
  try {
    // Generate both Word and PDF reports
    const wordFilename = await generateOBC1WordReport(results);
    const pdfFilename = await generateOBC1PDFReport(results);
    
    return `${wordFilename} and ${pdfFilename}`;
  } catch (error) {
    console.error('‚ùå Error generating OBC-1 reports:', error);
    throw new Error(`Failed to generate OBC-1 reports: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a Word document report for OBC-1 checkout results
 * 
 * @param results The OBC-1 test results
 * @returns A promise that resolves to the filename of the saved report
 */
async function generateOBC1WordReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `OBC-1_Checkout_${dateStr}_${timeStr}.docx`;
  
  console.log(`üìù Generating OBC-1 Word report: ${filename}`);
  
  // Create the document
  const doc = new Document({
    sections: [{
      properties: {},
      children: [
        // Title
        new Paragraph({
          text: "OBC-1 Automated Self Check Out Test Report",
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 200 }
        }),
        
        // Test metadata
        new Paragraph({
          text: `Test Version: 24.3.21`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Date: ${now.toLocaleDateString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Time: ${now.toLocaleTimeString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Generated by: SATS - Satellite Automated Testing System`,
          spacing: { after: 200 }
        }),
        
        // Test Summary
        new Paragraph({
          text: "Test Summary",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`,
          spacing: { after: 100 }
        }),
        
        // Separator
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Firmware Version section
        new Paragraph({
          text: "* Firmware Version:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Current OBC-1 Firmware Version: ${results.firmware?.major || 'N/A'}.${results.firmware?.minor || 'N/A'}.${results.firmware?.patch || 'N/A'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // Kernel Information section
        new Paragraph({
          text: "* Kernel Information:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Create kernel info table
        ...(results.kernel ? [createKernelInfoTable(results)] : [new Paragraph({
          text: "Kernel information not available",
          spacing: { after: 100 }
        })]),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // FPGA section
        new Paragraph({
          text: "* FPGA Voltage Current Temperature Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Create FPGA info paragraphs
        ...(results.fpga ? createFpgaInfoParagraphs(results) : [new Paragraph({
          text: "FPGA information not available",
          spacing: { after: 100 }
        })]),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // Voltage Current Temperature section
        new Paragraph({
          text: "* Voltage Current Temperature Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Create VI info paragraphs
        ...(results.vi && results.temperatures ? createViInfoParagraphs(results) : [new Paragraph({
          text: "Voltage and temperature information not available",
          spacing: { after: 100 }
        })]),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // eMMC section (if enabled)
        new Paragraph({
          text: "* eMMC test summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Create eMMC info paragraphs
        ...(results.emmc ? createEmmcInfoParagraphs(results) : [new Paragraph({
          text: "eMMC test information not available",
          spacing: { after: 100 }
        })]),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Test Completion Summary
        new Paragraph({
          text: "* Test Completion Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: results.error ? `Test completed with errors: ${results.error}` : "All tests completed successfully",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Report generated: ${now.toLocaleString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
      ]
    }]
  });
  
  try {
    // Generate the document
    console.log('üîÑ Generating Word document...');
    const buffer = await Packer.toBuffer(doc);
    
    // Save the file using file-saver (this will save to the user's default Downloads folder)
    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
    saveAs(blob, filename);
    
    console.log(`‚úÖ OBC-1 Word report saved successfully: ${filename}`);
    
    // Mark the report as generated
    if (results && typeof results === 'object') {
      results.reportGenerated = true;
    }
    
    return filename;
  } catch (error) {
    console.error('‚ùå Error generating OBC-1 Word report:', error);
    throw new Error(`Failed to generate OBC-1 Word report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a PDF report for OBC-1 checkout results
 * 
 * @param results The OBC-1 test results
 * @returns A promise that resolves to the filename of the saved PDF report
 */
async function generateOBC1PDFReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `OBC-1_Checkout_${dateStr}_${timeStr}.pdf`;
  
  console.log(`üìù Generating OBC-1 PDF report: ${filename}`);
  
  try {
    // Create new PDF document
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Set up the document
    let yPosition = 20;
    const pageWidth = pdf.internal.pageSize.width;
    const pageHeight = pdf.internal.pageSize.height;
    const margin = 20;
    const contentWidth = pageWidth - (2 * margin);

    // Helper function to check if we need a new page
    const checkNewPage = (requiredSpace: number = 20) => {
      if (yPosition + requiredSpace > pageHeight - 30) {
        pdf.addPage();
        yPosition = 20;
        return true;
      }
      return false;
    };

    // Title
    pdf.setFontSize(18);
    pdf.setFont('helvetica', 'bold');
    pdf.text('OBC-1 Automated Self Check Out Test Report', margin, yPosition);
    yPosition += 15;

    // Subtitle
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Generated by SATS - Satellite Automated Testing System', margin, yPosition);
    yPosition += 10;

    // Test metadata
    pdf.setFontSize(10);
    pdf.text(`Test Date: ${now.toLocaleDateString()}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Test Time: ${now.toLocaleTimeString()}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`, margin, yPosition);
    yPosition += 15;

    // Add a separator line
    pdf.line(margin, yPosition, pageWidth - margin, yPosition);
    yPosition += 10;

    // Firmware Version Section
    checkNewPage(30);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Firmware Version', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.firmware) {
      pdf.text(`Version: ${results.firmware.major || 'N/A'}.${results.firmware.minor || 'N/A'}.${results.firmware.patch || 'N/A'}`, margin, yPosition);
    } else {
      pdf.text('Firmware information not available', margin, yPosition);
    }
    yPosition += 15;

    // Kernel Information Section
    checkNewPage(50);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Kernel Information', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.kernel) {
      const kernelData = results.kernel;
      pdf.text(`Uptime: ${kernelData.uptime || 'N/A'} seconds`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Load Average (1m): ${kernelData.loads?.oneMinute || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Load Average (5m): ${kernelData.loads?.fiveMinute || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Load Average (15m): ${kernelData.loads?.fifteenMinute || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Total RAM: ${kernelData.memory?.totalRam || 'N/A'} bytes`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Free RAM: ${kernelData.memory?.freeRam || 'N/A'} bytes`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Processes: ${kernelData.processes || 'N/A'}`, margin, yPosition);
    } else {
      pdf.text('Kernel information not available', margin, yPosition);
    }
    yPosition += 15;

    // FPGA Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('FPGA Voltages & Temperatures', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.fpga) {
      const fpgaData = results.fpga;
      if (fpgaData.voltages) {
        pdf.text(`vcc_pspll: ${fpgaData.voltages.vccPspll || 'N/A'} V`, margin, yPosition);
        yPosition += 6;
        pdf.text(`vcc_psbatt: ${fpgaData.voltages.vccPsbatt || 'N/A'} V`, margin, yPosition);
        yPosition += 6;
        pdf.text(`vccint: ${fpgaData.voltages.vccint || 'N/A'} V`, margin, yPosition);
        yPosition += 6;
      }
      if (fpgaData.temperatures) {
        pdf.text(`PS Temperature: ${fpgaData.temperatures.psTemp || 'N/A'} ¬∞C`, margin, yPosition);
        yPosition += 6;
        pdf.text(`Remote Temperature: ${fpgaData.temperatures.remoteTemp || 'N/A'} ¬∞C`, margin, yPosition);
        yPosition += 6;
        pdf.text(`PL Temperature: ${fpgaData.temperatures.plTemp || 'N/A'} ¬∞C`, margin, yPosition);
        yPosition += 6;
      }
    } else {
      pdf.text('FPGA information not available', margin, yPosition);
    }
    yPosition += 15;

    // Voltage & Current Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Voltage & Current Measurements', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.vi) {
      const viData = results.vi;
      pdf.text(`OBC-1 3V3 D: ${viData.d3v3?.value || 'N/A'} mV (${viData.d3v3?.pass ? 'PASS' : 'FAIL'})`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PS 3V3 OBC-2: ${viData.ps3v3Obc2?.value || 'N/A'} mV (${viData.ps3v3Obc2?.pass ? 'PASS' : 'FAIL'})`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PS 5V OBC-2: ${viData.ps5vObc2?.value || 'N/A'} mV (${viData.ps5vObc2?.pass ? 'PASS' : 'FAIL'})`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PS 5V OBC-2 Current: ${viData.ps5vObc2I || 'N/A'} mA`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PS 3V3 OBC-2 Current: ${viData.ps3v3Obc2I || 'N/A'} mA`, margin, yPosition);
      yPosition += 6;
    } else {
      pdf.text('Voltage and current information not available', margin, yPosition);
    }
    yPosition += 15;

    // Temperature Sensors Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Temperature Sensors', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.temperatures) {
      const tempData = results.temperatures;
      pdf.text(`Thruster 1: ${tempData.thruster1 || 'N/A'} ¬∞C`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Thruster 2: ${tempData.thruster2 || 'N/A'} ¬∞C`, margin, yPosition);
      yPosition += 6;
      if (tempData.leocam && Array.isArray(tempData.leocam)) {
        tempData.leocam.forEach((temp: string, index: number) => {
          pdf.text(`LEOCAM ${index + 1}: ${temp || 'N/A'} ¬∞C`, margin, yPosition);
          yPosition += 6;
        });
      }
    } else {
      pdf.text('Temperature sensor information not available', margin, yPosition);
    }
    yPosition += 15;

    // eMMC Section (if available)
    if (results.emmc && results.emmc.emmc0States && results.emmc.emmc0States.length > 0 && results.emmc.emmc0States[0] !== 'N.A.') {
      checkNewPage(50);
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('eMMC Test Results', margin, yPosition);
      yPosition += 10;

      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.text('eMMC State Transitions:', margin, yPosition);
      yPosition += 8;

      const emmcData = results.emmc;
      const states = [
        'Before ON eMMC-0',
        'After ON eMMC-0',
        'After OFF eMMC-0',
        'Before ON eMMC-1',
        'After ON eMMC-1',
        'After OFF eMMC-1'
      ];

      states.forEach((stateName, index) => {
        if (index < emmcData.emmc0States.length) {
          pdf.text(`${stateName}: eMMC-0=${emmcData.emmc0States[index] || 'N/A'}, eMMC-1=${emmcData.emmc1States[index] || 'N/A'}`, margin, yPosition);
          yPosition += 6;
        }
      });
    }

    // Add footer to all pages
    const totalPages = pdf.internal.pages.length - 1;
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 20, pageHeight - 10);
      pdf.text(`Generated: ${now.toLocaleString()}`, margin, pageHeight - 10);
    }

    // Save the PDF
    pdf.save(filename);

    console.log(`‚úÖ OBC-1 PDF report saved successfully: ${filename}`);
    return filename;

  } catch (error) {
    console.error('‚ùå Error generating OBC-1 PDF report:', error);
    throw new Error(`Failed to generate OBC-1 PDF report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Helper function to create kernel info table
function createKernelInfoTable(results: any): Table {
  const kernelData = results.kernel || {};
  
  const rows = [
    ['Uptime', `${kernelData.uptime || 'N/A'} s`],
    ['1 minute average loads', kernelData.loads?.oneMinute || 'N/A'],
    ['5 minutes average loads', kernelData.loads?.fiveMinute || 'N/A'],
    ['15 minutes average loads', kernelData.loads?.fifteenMinute || 'N/A'],
    ['Total usable main memory size', `${kernelData.memory?.totalRam || 'N/A'} bytes`],
    ['Available memory size', `${kernelData.memory?.freeRam || 'N/A'} bytes`],
    ['Amount of shared memory', `${kernelData.memory?.sharedRam || 'N/A'} bytes`],
    ['Memory used by buffers', `${kernelData.memory?.bufferRam || 'N/A'} bytes`],
    ['Total swap space size', `${kernelData.memory?.totalSwap || 'N/A'} bytes`],
    ['Swap space still available', `${kernelData.memory?.freeSwap || 'N/A'} bytes`],
    ['Number of current processes', `${kernelData.processes || 'N/A'}`],
    ['Total high memory size', `${kernelData.memory?.totalHigh || 'N/A'} bytes`],
    ['Available high memory size', `${kernelData.memory?.freeHigh || 'N/A'} bytes`],
    ['Memory unit size in bytes', `${kernelData.memory?.memUnit || 'N/A'} bytes`]
  ].map(row => new TableRow({
    children: [
      new TableCell({
        children: [new Paragraph(row[0])],
        width: { size: 60, type: WidthType.PERCENTAGE }
      }),
      new TableCell({
        children: [new Paragraph(row[1])],
        width: { size: 40, type: WidthType.PERCENTAGE }
      })
    ]
  }));

  return new Table({
    rows,
    width: { size: 100, type: WidthType.PERCENTAGE },
    borders: {
      top: { style: BorderStyle.SINGLE, size: 1 },
      bottom: { style: BorderStyle.SINGLE, size: 1 },
      left: { style: BorderStyle.SINGLE, size: 1 },
      right: { style: BorderStyle.SINGLE, size: 1 },
      insideHorizontal: { style: BorderStyle.SINGLE, size: 1 },
      insideVertical: { style: BorderStyle.SINGLE, size: 1 }
    }
  });
}

// Helper function to create FPGA info paragraphs
function createFpgaInfoParagraphs(results: any): Paragraph[] {
  const fpgaData = results.fpga || {};
  const voltages = fpgaData.voltages || {};
  const temperatures = fpgaData.temperatures || {};
  
  return [
    new Paragraph(`vcc_pspll       : ${padString(voltages.vccPspll || 'N/A', 4)} V`),
    new Paragraph(`vcc_psbatt      : ${padString(voltages.vccPsbatt || 'N/A', 4)} V`),
    new Paragraph(`vccint          : ${padString(voltages.vccint || 'N/A', 4)} V`),
    new Paragraph(`vccbram         : ${padString(voltages.vccbram || 'N/A', 4)} V`),
    new Paragraph(`vccaux          : ${padString(voltages.vccaux || 'N/A', 4)} V`),
    new Paragraph(`ps_temp         : ${padString(temperatures.psTemp || 'N/A', 4)} deg C`),
    new Paragraph(`remote_temp     : ${padString(temperatures.remoteTemp || 'N/A', 4)} deg C`),
    new Paragraph(`pl_temp         : ${padString(temperatures.plTemp || 'N/A', 4)} deg C`)
  ];
}

// Helper function to create VI info paragraphs
function createViInfoParagraphs(results: any): Paragraph[] {
  const viData = results.vi || {};
  const tempData = results.temperatures || {};
  
  return [
    new Paragraph(`OBC-1 3V3 D V           : ${padString(viData.d3v3?.value || 'N/A', 4)} mV`),
    new Paragraph(`OBC-1 PS 3V3 OBC-2 V    : ${padString(viData.ps3v3Obc2?.value || 'N/A', 4)} mV`),
    new Paragraph(`OBC-1 PS 5V OBC-2 V     : ${padString(viData.ps5vObc2?.value || 'N/A', 4)} mV`),
    new Paragraph(`OBC-1 PS 5V OBC-2 I     : ${padString(viData.ps5vObc2I || 'N/A', 4)} mA`),
    new Paragraph(`OBC-1 PS 3V3 OBC-2 I    : ${padString(viData.ps3v3Obc2I || 'N/A', 4)} mA`),
    new Paragraph(``),
    new Paragraph(`Thruster thermistor 1   : ${padString(tempData.thruster1 || 'N/A', 3)} deg C`),
    new Paragraph(`Thruster thermistor 2   : ${padString(tempData.thruster2 || 'N/A', 3)} deg C`),
    new Paragraph(`LEOCAM thermistor 1     : ${padString(tempData.leocam?.[0] || 'N/A', 3)} deg C`),
    new Paragraph(`LEOCAM thermistor 2     : ${padString(tempData.leocam?.[1] || 'N/A', 3)} deg C`),
    new Paragraph(`LEOCAM thermistor 3     : ${padString(tempData.leocam?.[2] || 'N/A', 3)} deg C`),
    new Paragraph(`LEOCAM thermistor 4     : ${padString(tempData.leocam?.[3] || 'N/A', 3)} deg C`)
  ];
}

// Helper function to create eMMC info paragraphs
function createEmmcInfoParagraphs(results: any): Paragraph[] {
  const emmcData = results.emmc || {};
  
  if (!emmcData.emmc0States || emmcData.emmc0States.length === 0 || emmcData.emmc0States[0] === 'N.A.') {
    return [new Paragraph('eMMC test was not performed or data not available')];
  }
  
  const emmc0States = emmcData.emmc0States || [];
  const emmc1States = emmcData.emmc1States || [];
  
  return [
    new Paragraph('eMMC state before on eMMC-0 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[0] || 'N/A', 3)}`),
    new Paragraph(`eMMC-1 : ${padString(emmc1States[0] || 'N/A', 3)}`),
    new Paragraph('eMMC state after on eMMC-0 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[1] || 'N/A', 3)}`),
    new Paragraph(`eMMC-1 : ${padString(emmc1States[1] || 'N/A', 3)}`),
    new Paragraph('eMMC state after off eMMC-0 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[2] || 'N/A', 3)}`),
    new Paragraph(`eMMC-1 : ${padString(emmc1States[2] || 'N/A', 3)}`),
    new Paragraph('eMMC state before on eMMC-1 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[3] || 'N/A', 3)}`),
    new Paragraph(`eMMC-1 : ${padString(emmc1States[3] || 'N/A', 3)}`),
    new Paragraph('eMMC state after on eMMC-1 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[4] || 'N/A', 3)}`),
    new Paragraph(`eMMC-1 : ${padString(emmc1States[4] || 'N/A', 3)}`),
    new Paragraph('eMMC state after off eMMC-1 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[5] || 'N/A', 3)}`),
new Paragraph(`eMMC-1 : ${padString(emmc1States[5] || 'N/A', 3)}`)
  ];
}

/**
 * Utility function to pad a string to a specific length
 * 
 * @param value The string value to pad
 * @param length The desired length
 * @returns The padded string
 */
function padString(value: string, length: number): string {
  if (!value) return ''.padStart(length, ' ');
  return value.toString().padStart(length, ' ');
}