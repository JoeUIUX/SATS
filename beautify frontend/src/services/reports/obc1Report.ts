// src/services/reports/obc1Report.ts - Enhanced with all parameters
import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, BorderStyle, WidthType, AlignmentType } from 'docx';
import { saveAs } from 'file-saver';
import jsPDF from 'jspdf';

/**
 * Generate both Word document and PDF reports for OBC-1 checkout results
 * 
 * @param results The OBC-1 test results
 * @returns A promise that resolves to the filename of the saved reports
 */
export async function generateOBC1Report(results: any): Promise<string> {
  try {
    // Generate both Word and PDF reports
    const wordFilename = await generateOBC1WordReport(results);
    const pdfFilename = await generateOBC1PDFReport(results);
    
    return `${wordFilename} and ${pdfFilename}`;
  } catch (error) {
    console.error('‚ùå Error generating OBC-1 reports:', error);
    throw new Error(`Failed to generate OBC-1 reports: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a Word document report for OBC-1 checkout results
 * 
 * @param results The OBC-1 test results
 * @returns A promise that resolves to the filename of the saved report
 */
async function generateOBC1WordReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `OBC-1_Checkout_${dateStr}_${timeStr}.docx`;
  
  console.log(`üìù Generating OBC-1 Word report: ${filename}`);
  
  // Create the document
  const doc = new Document({
    sections: [{
      properties: {},
      children: [
        // Title
        new Paragraph({
          text: "OBC-1 Automated Self Check Out Test Report",
          heading: HeadingLevel.HEADING_1,
          spacing: { after: 200 }
        }),
        
        // Test metadata
        new Paragraph({
          text: `Test Version: 24.3.21`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Date: ${now.toLocaleDateString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Time: ${now.toLocaleTimeString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Generated by: SATS - Satellite Automated Testing System`,
          spacing: { after: 200 }
        }),
        
        // Test Summary
        new Paragraph({
          text: "Test Summary",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Simulation Mode: ${results._simulationUsed || results.simulated ? 'YES' : 'NO'}`,
          spacing: { after: 100 }
        }),
        
        // Separator
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200 }
        }),
        
        // Firmware Version section
        new Paragraph({
          text: "* Firmware Version:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Current OBC-1 Firmware Version: ${results.firmware?.major || 'N/A'}.${results.firmware?.minor || 'N/A'}.${results.firmware?.patch || 'N/A'}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // Kernel Information section
        new Paragraph({
          text: "* Kernel Information:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Create kernel info table
        ...(results.kernel ? [createKernelInfoTable(results)] : [new Paragraph({
          text: "Kernel information not available",
          spacing: { after: 100 }
        })]),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // FPGA section - Enhanced with all voltage parameters
        new Paragraph({
          text: "* FPGA Voltage Current Temperature Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Create comprehensive FPGA info paragraphs
        ...(results.fpga || results.rawParameters ? createComprehensiveFpgaInfoParagraphs(results) : [new Paragraph({
          text: "FPGA information not available",
          spacing: { after: 100 }
        })]),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // Voltage Current Temperature section
        new Paragraph({
          text: "* Voltage Current Temperature Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Create VI info paragraphs
        ...(results.vi && results.temperatures ? createViInfoParagraphs(results) : [new Paragraph({
          text: "Voltage and temperature information not available",
          spacing: { after: 100 }
        })]),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),
        
        // eMMC section (if enabled)
        new Paragraph({
          text: "* eMMC test summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Create eMMC info paragraphs
        ...(results.emmc ? createEmmcInfoParagraphs(results) : [new Paragraph({
          text: "eMMC test information not available",
          spacing: { after: 100 }
        })]),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),

        // Page break
        new Paragraph({
          text: "",
          pageBreakBefore: true
        }),

        // Raw Parameters section
        new Paragraph({
          text: "* Raw Parameter Values:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        
        // Create raw parameters table
        ...(results.rawParameters ? [createRawParametersTable(results)] : [new Paragraph({
          text: "Raw parameter information not available",
          spacing: { after: 100 }
        })]),
        
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
        
        // Test Completion Summary
        new Paragraph({
          text: "* Test Completion Summary:",
          heading: HeadingLevel.HEADING_2,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: results.error ? `Test completed with errors: ${results.error}` : "All tests completed successfully",
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: `Report generated: ${now.toLocaleString()}`,
          spacing: { after: 100 }
        }),
        new Paragraph({
          text: "--------------------------------------------------------------------",
          spacing: { after: 200, before: 200 }
        }),
      ]
    }]
  });
  
  try {
    // Generate the document
    console.log('üîÑ Generating Word document...');
    const buffer = await Packer.toBuffer(doc);
    
    // Save the file using file-saver (this will save to the user's default Downloads folder)
    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
    saveAs(blob, filename);
    
    console.log(`‚úÖ OBC-1 Word report saved successfully: ${filename}`);
    
    // Mark the report as generated
    if (results && typeof results === 'object') {
      results.reportGenerated = true;
    }
    
    return filename;
  } catch (error) {
    console.error('‚ùå Error generating OBC-1 Word report:', error);
    throw new Error(`Failed to generate OBC-1 Word report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Generate a PDF report for OBC-1 checkout results
 * 
 * @param results The OBC-1 test results
 * @returns A promise that resolves to the filename of the saved PDF report
 */
async function generateOBC1PDFReport(results: any): Promise<string> {
  // Get current date and time for the report filename
  const now = new Date();
  const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
  const timeStr = now.toTimeString().split(' ')[0].replace(/:/g, '-'); // HH-MM-SS
  const filename = `OBC-1_Checkout_${dateStr}_${timeStr}.pdf`;
  
  console.log(`üìù Generating OBC-1 PDF report: ${filename}`);
  
  try {
    // Create new PDF document
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4'
    });

    // Set up the document
    let yPosition = 20;
    const pageWidth = pdf.internal.pageSize.width;
    const pageHeight = pdf.internal.pageSize.height;
    const margin = 20;
    const contentWidth = pageWidth - (2 * margin);

    // Helper function to check if we need a new page
    const checkNewPage = (requiredSpace: number = 20) => {
      if (yPosition + requiredSpace > pageHeight - 30) {
        pdf.addPage();
        yPosition = 20;
        return true;
      }
      return false;
    };

    // Title
    pdf.setFontSize(18);
    pdf.setFont('helvetica', 'bold');
    pdf.text('OBC-1 Automated Self Check Out Test Report', margin, yPosition);
    yPosition += 15;

    // Subtitle
    pdf.setFontSize(12);
    pdf.setFont('helvetica', 'normal');
    pdf.text('Generated by SATS - Satellite Automated Testing System', margin, yPosition);
    yPosition += 10;

    // Test metadata
    pdf.setFontSize(10);
    pdf.text(`Test Date: ${now.toLocaleDateString()}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Test Time: ${now.toLocaleTimeString()}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Tested Options: ${results.testedOptions ? results.testedOptions.join(', ') : 'Default configuration'}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Test Status: ${results.error ? 'FAILED' : 'COMPLETED'}`, margin, yPosition);
    yPosition += 6;
    pdf.text(`Simulation Mode: ${results._simulationUsed || results.simulated ? 'YES' : 'NO'}`, margin, yPosition);
    yPosition += 15;

    // Add a separator line
    pdf.line(margin, yPosition, pageWidth - margin, yPosition);
    yPosition += 10;

    // Firmware Version Section
    checkNewPage(30);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Firmware Version', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.firmware) {
      pdf.text(`Version: ${results.firmware.major || 'N/A'}.${results.firmware.minor || 'N/A'}.${results.firmware.patch || 'N/A'}`, margin, yPosition);
    } else {
      pdf.text('Firmware information not available', margin, yPosition);
    }
    yPosition += 15;

    // Kernel Information Section
    checkNewPage(80);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Kernel Information', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.kernel) {
      const kernelData = results.kernel;
      pdf.text(`Uptime: ${kernelData.uptime || 'N/A'} seconds`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Load Average (1m): ${kernelData.loads?.oneMinute || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Load Average (5m): ${kernelData.loads?.fiveMinute || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Load Average (15m): ${kernelData.loads?.fifteenMinute || 'N/A'}`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Total RAM: ${kernelData.memory?.totalRam || 'N/A'} bytes`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Free RAM: ${kernelData.memory?.freeRam || 'N/A'} bytes`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Shared RAM: ${kernelData.memory?.sharedRam || 'N/A'} bytes`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Buffer RAM: ${kernelData.memory?.bufferRam || 'N/A'} bytes`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Total Swap: ${kernelData.memory?.totalSwap || 'N/A'} bytes`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Free Swap: ${kernelData.memory?.freeSwap || 'N/A'} bytes`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Total High: ${kernelData.memory?.totalHigh || 'N/A'} bytes`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Free High: ${kernelData.memory?.freeHigh || 'N/A'} bytes`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Memory Unit: ${kernelData.memory?.memUnit || 'N/A'} bytes`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Processes: ${kernelData.processes || 'N/A'}`, margin, yPosition);
    } else {
      pdf.text('Kernel information not available', margin, yPosition);
    }
    yPosition += 15;

    // FPGA Section
    checkNewPage(120);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('FPGA Voltages & Temperatures', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    
    // All FPGA voltages from the checkout variables
    const fpgaVoltageParams = [
      { param: 'OBC1_vcc_pspll', label: 'vcc_pspll' },
      { param: 'OBC1_vcc_psbatt', label: 'vcc_psbatt' },
      { param: 'OBC1_vccint', label: 'vccint' },
      { param: 'OBC1_vccbram', label: 'vccbram' },
      { param: 'OBC1_vccaux', label: 'vccaux' },
      { param: 'OBC1_vcc_psddr_pll', label: 'vcc_psddr_pll' },
      { param: 'OBC1_vccpsintfp_ddr', label: 'vccpsintfp_ddr' },
      { param: 'OBC1_vccint1', label: 'vccint1' },
      { param: 'OBC1_vccaux1', label: 'vccaux1' },
      { param: 'OBC1_vccvrefp', label: 'vccvrefp' },
      { param: 'OBC1_vccvrefn', label: 'vccvrefn' },
      { param: 'OBC1_vccbram1', label: 'vccbram1' },
      { param: 'OBC1_vccplintlp', label: 'vccplintlp' },
      { param: 'OBC1_vccplintfp', label: 'vccplintfp' },
      { param: 'OBC1_vccplaux', label: 'vccplaux' },
      { param: 'OBC1_vccams', label: 'vccams' },
      { param: 'OBC1_vccpsintlp', label: 'vccpsintlp' },
      { param: 'OBC1_vccpsintfp', label: 'vccpsintfp' },
      { param: 'OBC1_vccpsaux', label: 'vccpsaux' },
      { param: 'OBC1_vccpsddr', label: 'vccpsddr' },
      { param: 'OBC1_vccpsio3', label: 'vccpsio3' },
      { param: 'OBC1_vccpsio0', label: 'vccpsio0' },
      { param: 'OBC1_vccpsio1', label: 'vccpsio1' },
      { param: 'OBC1_vccpsio2', label: 'vccpsio2' },
      { param: 'OBC1_psmgtravcc', label: 'psmgtravcc' },
      { param: 'OBC1_psmgtravtt', label: 'psmgtravtt' },
      { param: 'OBC1_vccams1', label: 'vccams1' },
    ];

    // Print all FPGA voltages
    for (const voltage of fpgaVoltageParams) {
      checkNewPage(6);
      const value = results.rawParameters?.[voltage.param] || 
                   (results.fpga?.voltages && getNestedValue(results.fpga.voltages, voltage.param)) || 
                   'N/A';
      pdf.text(`${voltage.label}: ${value} V`, margin, yPosition);
      yPosition += 6;
    }

    // FPGA temperatures
    checkNewPage(20);
    const fpgaTempParams = [
      { param: 'OBC1_ps_temp', label: 'PS Temperature' },
      { param: 'OBC1_remote_temp', label: 'Remote Temperature' },
      { param: 'OBC1_pl_temp', label: 'PL Temperature' }
    ];

    for (const temp of fpgaTempParams) {
      const value = results.rawParameters?.[temp.param] || 
                   (results.fpga?.temperatures && getNestedValue(results.fpga.temperatures, temp.param)) || 
                   'N/A';
      pdf.text(`${temp.label}: ${value} ¬∞C`, margin, yPosition);
      yPosition += 6;
    }
    yPosition += 10;

    // Voltage & Current Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Voltage & Current Measurements', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.vi) {
      const viData = results.vi;
      pdf.text(`OBC-1 3V3 D: ${viData.d3v3?.value || 'N/A'} mV (${viData.d3v3?.pass ? 'PASS' : 'FAIL'})`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PS 3V3 OBC-2: ${viData.ps3v3Obc2?.value || 'N/A'} mV (${viData.ps3v3Obc2?.pass ? 'PASS' : 'FAIL'})`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PS 5V OBC-2: ${viData.ps5vObc2?.value || 'N/A'} mV (${viData.ps5vObc2?.pass ? 'PASS' : 'FAIL'})`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PS 5V OBC-2 Current: ${viData.ps5vObc2I || 'N/A'} mA`, margin, yPosition);
      yPosition += 6;
      pdf.text(`PS 3V3 OBC-2 Current: ${viData.ps3v3Obc2I || 'N/A'} mA`, margin, yPosition);
      yPosition += 6;
    } else {
      pdf.text('Voltage and current information not available', margin, yPosition);
    }
    yPosition += 15;

    // Temperature Sensors Section
    checkNewPage(40);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Temperature Sensors', margin, yPosition);
    yPosition += 10;

    pdf.setFontSize(10);
    pdf.setFont('helvetica', 'normal');
    if (results.temperatures) {
      const tempData = results.temperatures;
      pdf.text(`Thruster 1: ${tempData.thruster1 || 'N/A'} ¬∞C`, margin, yPosition);
      yPosition += 6;
      pdf.text(`Thruster 2: ${tempData.thruster2 || 'N/A'} ¬∞C`, margin, yPosition);
      yPosition += 6;
      if (tempData.leocam && Array.isArray(tempData.leocam)) {
        tempData.leocam.forEach((temp: string, index: number) => {
          checkNewPage(6);
          pdf.text(`LEOCAM ${index + 1}: ${temp || 'N/A'} ¬∞C`, margin, yPosition);
          yPosition += 6;
        });
      }
    } else {
      pdf.text('Temperature sensor information not available', margin, yPosition);
    }
    yPosition += 15;

    // eMMC Section (if available)
    if (results.emmc && results.emmc.emmc0States && results.emmc.emmc0States.length > 0 && results.emmc.emmc0States[0] !== 'N.A.') {
      checkNewPage(50);
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.text('eMMC Test Results', margin, yPosition);
      yPosition += 10;

      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.text('eMMC State Transitions:', margin, yPosition);
      yPosition += 8;

      const emmcData = results.emmc;
      const states = [
        'Before ON eMMC-0',
        'After ON eMMC-0',
        'After OFF eMMC-0',
        'Before ON eMMC-1',
        'After ON eMMC-1',
        'After OFF eMMC-1'
      ];

      states.forEach((stateName, index) => {
        if (index < emmcData.emmc0States.length) {
          checkNewPage(6);
          pdf.text(`${stateName}: eMMC-0=${emmcData.emmc0States[index] || 'N/A'}, eMMC-1=${emmcData.emmc1States[index] || 'N/A'}`, margin, yPosition);
          yPosition += 6;
        }
      });
      yPosition += 10;
    }

    // Raw Parameters Section
    checkNewPage(60);
    pdf.setFontSize(14);
    pdf.setFont('helvetica', 'bold');
    pdf.text('Complete Raw Parameter Values', margin, yPosition);
    yPosition += 10;

    if (results.rawParameters) {
      const rawParams = results.rawParameters;
      
      // Parameter groups matching the Word document
      const parameterGroups = {
        'Firmware Parameters': [
          'OBC1_FW_Ver_Major',
          'OBC1_FW_Ver_Minor', 
          'OBC1_FW_Ver_Patch'
        ],
        'Kernel Parameters': [
          'OBC1_Sys_uptime',
          'OBC1_Sys_loads_1m',
          'OBC1_Sys_loads_5m', 
          'OBC1_Sys_loads_15m',
          'OBC1_Sys_totalram',
          'OBC1_Sys_freeram',
          'OBC1_Sys_sharedram',
          'OBC1_Sys_bufferram',
          'OBC1_Sys_totalswap',
          'OBC1_Sys_freeswap',
          'OBC1_Sys_procs',
          'OBC1_Sys_pad',
          'OBC1_Sys_totalhigh',
          'OBC1_Sys_freehigh',
          'OBC1_Sys_mem_unit'
        ],
        'FPGA Voltage Parameters': [
          'OBC1_vcc_pspll',
          'OBC1_vcc_psbatt',
          'OBC1_vccint',
          'OBC1_vccbram',
          'OBC1_vccaux',
          'OBC1_vcc_psddr_pll',
          'OBC1_vccpsintfp_ddr',
          'OBC1_vccint1',
          'OBC1_vccaux1',
          'OBC1_vccvrefp',
          'OBC1_vccvrefn',
          'OBC1_vccbram1',
          'OBC1_vccplintlp',
          'OBC1_vccplintfp',
          'OBC1_vccplaux',
          'OBC1_vccams',
          'OBC1_vccpsintlp',
          'OBC1_vccpsintfp',
          'OBC1_vccpsaux',
          'OBC1_vccpsddr',
          'OBC1_vccpsio3',
          'OBC1_vccpsio0',
          'OBC1_vccpsio1',
          'OBC1_vccpsio2',
          'OBC1_psmgtravcc',
          'OBC1_psmgtravtt',
          'OBC1_vccams1'
        ],
        'FPGA Temperature Parameters': [
          'OBC1_ps_temp',
          'OBC1_remote_temp',
          'OBC1_pl_temp'
        ],
        'Voltage & Current Parameters': [
          'OBC1_3V3_D',
          'OBC1_PS_3V3_OBC2_V',
          'OBC1_PS_5V_OBC2_V',
          'OBC1_PS_5V_OBC2_I',
          'OBC1_PS_3V3_OBC2_I'
        ],
        'Temperature Sensor Parameters': [
          'OBC1_thruster_ch1_T',
          'OBC1_thruster_ch2_T',
          'OBC1_leocam_ch1_T',
          'OBC1_leocam_ch2_T',
          'OBC1_leocam_ch3_T',
          'OBC1_leocam_ch4_T'
        ],
        'eMMC Parameters': [
          'OBC1_Q8_eMMC0_state',
          'OBC1_Q8_eMMC1_state'
        ]
      };

      // Display parameters by group
      Object.entries(parameterGroups).forEach(([groupName, params]) => {
        checkNewPage(20);
        
        // Group header
        pdf.setFontSize(12);
        pdf.setFont('helvetica', 'bold');
        pdf.text(groupName, margin, yPosition);
        yPosition += 8;
        
        // Parameters in this group
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'normal');
        
        params.forEach(param => {
          checkNewPage(6);
          const value = rawParams[param] || 'N/A';
          const displayText = `${param}: ${value}`;
          
          // Check if text is too long for one line
          const textWidth = pdf.getTextWidth(displayText);
          const maxWidth = contentWidth;
          
          if (textWidth > maxWidth) {
            // Split long text
            const colonIndex = displayText.indexOf(':');
            const paramName = displayText.substring(0, colonIndex + 1);
            const paramValue = displayText.substring(colonIndex + 1).trim();
            
            pdf.text(paramName, margin, yPosition);
            yPosition += 5;
            pdf.text(`    ${paramValue}`, margin, yPosition);
          } else {
            pdf.text(displayText, margin, yPosition);
          }
          yPosition += 5;
        });
        
        yPosition += 5; // Extra space after each group
      });

      // Add any additional parameters not in the predefined groups
      const definedParams = new Set(Object.values(parameterGroups).flat());
      const additionalParams = Object.keys(rawParams).filter(param => !definedParams.has(param));
      
      if (additionalParams.length > 0) {
        checkNewPage(20);
        
        pdf.setFontSize(12);
        pdf.setFont('helvetica', 'bold');
        pdf.text('Additional Parameters', margin, yPosition);
        yPosition += 8;
        
        pdf.setFontSize(9);
        pdf.setFont('helvetica', 'normal');
        
        additionalParams.forEach(param => {
          checkNewPage(6);
          const value = rawParams[param];
          const displayText = `${param}: ${value}`;
          
          // Check if text is too long for one line
          const textWidth = pdf.getTextWidth(displayText);
          const maxWidth = contentWidth;
          
          if (textWidth > maxWidth) {
            // Split long text
            const colonIndex = displayText.indexOf(':');
            const paramName = displayText.substring(0, colonIndex + 1);
            const paramValue = displayText.substring(colonIndex + 1).trim();
            
            pdf.text(paramName, margin, yPosition);
            yPosition += 5;
            pdf.text(`    ${paramValue}`, margin, yPosition);
          } else {
            pdf.text(displayText, margin, yPosition);
          }
          yPosition += 5;
        });
      }

      // Show summary at the end
      checkNewPage(15);
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'bold');
      const paramCount = Object.keys(rawParams).length;
      pdf.text(`Total parameters recorded: ${paramCount}`, margin, yPosition);
      yPosition += 6;
      
      // Show simulation status
      if (rawParams._simulation_used) {
        pdf.text(`Simulation used: ${rawParams._simulation_used}`, margin, yPosition);
        yPosition += 6;
      }
    } else {
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.text('Raw parameter information not available', margin, yPosition);
      yPosition += 10;
    }

    // Add footer to all pages
    const totalPages = pdf.internal.pages.length - 1;
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin - 20, pageHeight - 10);
      pdf.text(`Generated: ${now.toLocaleString()}`, margin, pageHeight - 10);
    }

    // Save the PDF
    pdf.save(filename);

    console.log(`‚úÖ OBC-1 PDF report saved successfully: ${filename}`);
    return filename;

  } catch (error) {
    console.error('‚ùå Error generating OBC-1 PDF report:', error);
    throw new Error(`Failed to generate OBC-1 PDF report: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Helper function to create comprehensive kernel info table
function createKernelInfoTable(results: any): Table {
  const kernelData = results.kernel || {};
  
  const rows = [
    ['Uptime', `${kernelData.uptime || 'N/A'} s`],
    ['1 minute average loads', kernelData.loads?.oneMinute || 'N/A'],
    ['5 minutes average loads', kernelData.loads?.fiveMinute || 'N/A'],
    ['15 minutes average loads', kernelData.loads?.fifteenMinute || 'N/A'],
    ['Total usable main memory size', `${kernelData.memory?.totalRam || 'N/A'} bytes`],
    ['Available memory size', `${kernelData.memory?.freeRam || 'N/A'} bytes`],
    ['Amount of shared memory', `${kernelData.memory?.sharedRam || 'N/A'} bytes`],
    ['Memory used by buffers', `${kernelData.memory?.bufferRam || 'N/A'} bytes`],
    ['Total swap space size', `${kernelData.memory?.totalSwap || 'N/A'} bytes`],
    ['Swap space still available', `${kernelData.memory?.freeSwap || 'N/A'} bytes`],
    ['Number of current processes', `${kernelData.processes || 'N/A'}`],
    ['Total high memory size', `${kernelData.memory?.totalHigh || 'N/A'} bytes`],
    ['Available high memory size', `${kernelData.memory?.freeHigh || 'N/A'} bytes`],
    ['Memory unit size in bytes', `${kernelData.memory?.memUnit || 'N/A'} bytes`]
  ].map(row => new TableRow({
    children: [
      new TableCell({
        children: [new Paragraph(row[0])],
        width: { size: 60, type: WidthType.PERCENTAGE }
      }),
      new TableCell({
        children: [new Paragraph(row[1])],
        width: { size: 40, type: WidthType.PERCENTAGE }
      })
    ]
  }));

  return new Table({
    rows,
    width: { size: 100, type: WidthType.PERCENTAGE },
    borders: {
      top: { style: BorderStyle.SINGLE, size: 1 },
      bottom: { style: BorderStyle.SINGLE, size: 1 },
      left: { style: BorderStyle.SINGLE, size: 1 },
      right: { style: BorderStyle.SINGLE, size: 1 },
      insideHorizontal: { style: BorderStyle.SINGLE, size: 1 },
      insideVertical: { style: BorderStyle.SINGLE, size: 1 }
    }
  });
}

// Helper function to create comprehensive FPGA info paragraphs
function createComprehensiveFpgaInfoParagraphs(results: any): Paragraph[] {
  const paragraphs: Paragraph[] = [];
  
  // FPGA Voltages Section
  paragraphs.push(new Paragraph({
    text: "FPGA Voltages:",
    spacing: { after: 100 },
    run: {
      bold: true
    }
  }));

  // All FPGA voltage parameters from the checkout
  const fpgaVoltageParams = [
    { param: 'OBC1_vcc_pspll', label: 'vcc_pspll' },
    { param: 'OBC1_vcc_psbatt', label: 'vcc_psbatt' },
    { param: 'OBC1_vccint', label: 'vccint' },
    { param: 'OBC1_vccbram', label: 'vccbram' },
    { param: 'OBC1_vccaux', label: 'vccaux' },
    { param: 'OBC1_vcc_psddr_pll', label: 'vcc_psddr_pll' },
    { param: 'OBC1_vccpsintfp_ddr', label: 'vccpsintfp_ddr' },
    { param: 'OBC1_vccint1', label: 'vccint1' },
    { param: 'OBC1_vccaux1', label: 'vccaux1' },
    { param: 'OBC1_vccvrefp', label: 'vccvrefp' },
    { param: 'OBC1_vccvrefn', label: 'vccvrefn' },
    { param: 'OBC1_vccbram1', label: 'vccbram1' },
    { param: 'OBC1_vccplintlp', label: 'vccplintlp' },
    { param: 'OBC1_vccplintfp', label: 'vccplintfp' },
    { param: 'OBC1_vccplaux', label: 'vccplaux' },
    { param: 'OBC1_vccams', label: 'vccams' },
    { param: 'OBC1_vccpsintlp', label: 'vccpsintlp' },
    { param: 'OBC1_vccpsintfp', label: 'vccpsintfp' },
    { param: 'OBC1_vccpsaux', label: 'vccpsaux' },
    { param: 'OBC1_vccpsddr', label: 'vccpsddr' },
    { param: 'OBC1_vccpsio3', label: 'vccpsio3' },
    { param: 'OBC1_vccpsio0', label: 'vccpsio0' },
    { param: 'OBC1_vccpsio1', label: 'vccpsio1' },
    { param: 'OBC1_vccpsio2', label: 'vccpsio2' },
    { param: 'OBC1_psmgtravcc', label: 'psmgtravcc' },
    { param: 'OBC1_psmgtravtt', label: 'psmgtravtt' },
    { param: 'OBC1_vccams1', label: 'vccams1' },
  ];

  // Add voltage paragraphs
  fpgaVoltageParams.forEach(voltage => {
    const value = results.rawParameters?.[voltage.param] || 
                 (results.fpga?.voltages && getNestedValue(results.fpga.voltages, voltage.param)) || 
                 'N/A';
    paragraphs.push(new Paragraph(`${voltage.label.padEnd(20)} : ${padString(value, 6)} V`));
  });

  // Add spacing
  paragraphs.push(new Paragraph({ text: "", spacing: { after: 100 } }));

  // FPGA Temperatures Section
  paragraphs.push(new Paragraph({
    text: "FPGA Temperatures:",
    spacing: { after: 100 },
    run: {
      bold: true
    }
  }));

  const fpgaTempParams = [
    { param: 'OBC1_ps_temp', label: 'ps_temp' },
    { param: 'OBC1_remote_temp', label: 'remote_temp' },
    { param: 'OBC1_pl_temp', label: 'pl_temp' }
  ];

  fpgaTempParams.forEach(temp => {
    const value = results.rawParameters?.[temp.param] || 
                 (results.fpga?.temperatures && getNestedValue(results.fpga.temperatures, temp.param)) || 
                 'N/A';
    paragraphs.push(new Paragraph(`${temp.label.padEnd(20)} : ${padString(value, 6)} deg C`));
  });

  return paragraphs;
}

// Helper function to create VI info paragraphs
function createViInfoParagraphs(results: any): Paragraph[] {
  const viData = results.vi || {};
  const tempData = results.temperatures || {};
  
  return [
    new Paragraph(`OBC-1 3V3 D V           : ${padString(viData.d3v3?.value || 'N/A', 4)} mV`),
    new Paragraph(`OBC-1 PS 3V3 OBC-2 V    : ${padString(viData.ps3v3Obc2?.value || 'N/A', 4)} mV`),
    new Paragraph(`OBC-1 PS 5V OBC-2 V     : ${padString(viData.ps5vObc2?.value || 'N/A', 4)} mV`),
    new Paragraph(`OBC-1 PS 5V OBC-2 I     : ${padString(viData.ps5vObc2I || 'N/A', 4)} mA`),
    new Paragraph(`OBC-1 PS 3V3 OBC-2 I    : ${padString(viData.ps3v3Obc2I || 'N/A', 4)} mA`),
    new Paragraph(``),
    new Paragraph(`Thruster thermistor 1   : ${padString(tempData.thruster1 || 'N/A', 3)} deg C`),
    new Paragraph(`Thruster thermistor 2   : ${padString(tempData.thruster2 || 'N/A', 3)} deg C`),
    new Paragraph(`LEOCAM thermistor 1     : ${padString(tempData.leocam?.[0] || 'N/A', 3)} deg C`),
    new Paragraph(`LEOCAM thermistor 2     : ${padString(tempData.leocam?.[1] || 'N/A', 3)} deg C`),
    new Paragraph(`LEOCAM thermistor 3     : ${padString(tempData.leocam?.[2] || 'N/A', 3)} deg C`),
    new Paragraph(`LEOCAM thermistor 4     : ${padString(tempData.leocam?.[3] || 'N/A', 3)} deg C`)
  ];
}

// Helper function to create eMMC info paragraphs
function createEmmcInfoParagraphs(results: any): Paragraph[] {
  const emmcData = results.emmc || {};
  
  if (!emmcData.emmc0States || emmcData.emmc0States.length === 0 || emmcData.emmc0States[0] === 'N.A.') {
    return [new Paragraph('eMMC test was not performed or data not available')];
  }
  
  const emmc0States = emmcData.emmc0States || [];
  const emmc1States = emmcData.emmc1States || [];
  
  return [
    new Paragraph('eMMC state before on eMMC-0 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[0] || 'N/A', 3)}`),
    new Paragraph(`eMMC-1 : ${padString(emmc1States[0] || 'N/A', 3)}`),
    new Paragraph('eMMC state after on eMMC-0 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[1] || 'N/A', 3)}`),
    new Paragraph(`eMMC-1 : ${padString(emmc1States[1] || 'N/A', 3)}`),
    new Paragraph('eMMC state after off eMMC-0 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[2] || 'N/A', 3)}`),
    new Paragraph(`eMMC-1 : ${padString(emmc1States[2] || 'N/A', 3)}`),
    new Paragraph('eMMC state before on eMMC-1 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[3] || 'N/A', 3)}`),
    new Paragraph(`eMMC-1 : ${padString(emmc1States[3] || 'N/A', 3)}`),
    new Paragraph('eMMC state after on eMMC-1 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[4] || 'N/A', 3)}`),
    new Paragraph(`eMMC-1 : ${padString(emmc1States[4] || 'N/A', 3)}`),
    new Paragraph('eMMC state after off eMMC-1 : -'),
    new Paragraph(`eMMC-0 : ${padString(emmc0States[5] || 'N/A', 3)}`),
    new Paragraph(`eMMC-1 : ${padString(emmc1States[5] || 'N/A', 3)}`)
  ];
}

// Helper function to create raw parameters table
function createRawParametersTable(results: any): Table {
  const rawParams = results.rawParameters || {};
  
  // Group parameters by category for better organization
  const parameterGroups = {
    'Firmware Parameters': [
      'OBC1_FW_Ver_Major',
      'OBC1_FW_Ver_Minor', 
      'OBC1_FW_Ver_Patch'
    ],
    'Kernel Parameters': [
      'OBC1_Sys_uptime',
      'OBC1_Sys_loads_1m',
      'OBC1_Sys_loads_5m', 
      'OBC1_Sys_loads_15m',
      'OBC1_Sys_totalram',
      'OBC1_Sys_freeram',
      'OBC1_Sys_sharedram',
      'OBC1_Sys_bufferram',
      'OBC1_Sys_totalswap',
      'OBC1_Sys_freeswap',
      'OBC1_Sys_procs',
      'OBC1_Sys_pad',
      'OBC1_Sys_totalhigh',
      'OBC1_Sys_freehigh',
      'OBC1_Sys_mem_unit'
    ],
    'FPGA Voltage Parameters': [
      'OBC1_vcc_pspll',
      'OBC1_vcc_psbatt',
      'OBC1_vccint',
      'OBC1_vccbram',
      'OBC1_vccaux',
      'OBC1_vcc_psddr_pll',
      'OBC1_vccpsintfp_ddr',
      'OBC1_vccint1',
      'OBC1_vccaux1',
      'OBC1_vccvrefp',
      'OBC1_vccvrefn',
      'OBC1_vccbram1',
      'OBC1_vccplintlp',
      'OBC1_vccplintfp',
      'OBC1_vccplaux',
      'OBC1_vccams',
      'OBC1_vccpsintlp',
      'OBC1_vccpsintfp',
      'OBC1_vccpsaux',
      'OBC1_vccpsddr',
      'OBC1_vccpsio3',
      'OBC1_vccpsio0',
      'OBC1_vccpsio1',
      'OBC1_vccpsio2',
      'OBC1_psmgtravcc',
      'OBC1_psmgtravtt',
      'OBC1_vccams1'
    ],
    'FPGA Temperature Parameters': [
      'OBC1_ps_temp',
      'OBC1_remote_temp',
      'OBC1_pl_temp'
    ],
    'Voltage & Current Parameters': [
      'OBC1_3V3_D',
      'OBC1_PS_3V3_OBC2_V',
      'OBC1_PS_5V_OBC2_V',
      'OBC1_PS_5V_OBC2_I',
      'OBC1_PS_3V3_OBC2_I'
    ],
    'Temperature Sensor Parameters': [
      'OBC1_thruster_ch1_T',
      'OBC1_thruster_ch2_T',
      'OBC1_leocam_ch1_T',
      'OBC1_leocam_ch2_T',
      'OBC1_leocam_ch3_T',
      'OBC1_leocam_ch4_T'
    ],
    'eMMC Parameters': [
      'OBC1_Q8_eMMC0_state',
      'OBC1_Q8_eMMC1_state'
    ]
  };

  const rows: TableRow[] = [];

  // Add header row
  rows.push(new TableRow({
    children: [
      new TableCell({
        children: [new Paragraph({
          text: "Parameter Category",
          run: { bold: true }
        })],
        width: { size: 40, type: WidthType.PERCENTAGE }
      }),
      new TableCell({
        children: [new Paragraph({
          text: "Parameter Name", 
          run: { bold: true }
        })],
        width: { size: 35, type: WidthType.PERCENTAGE }
      }),
      new TableCell({
        children: [new Paragraph({
          text: "Value",
          run: { bold: true }
        })],
        width: { size: 25, type: WidthType.PERCENTAGE }
      })
    ]
  }));

  // Add parameters by group
  Object.entries(parameterGroups).forEach(([groupName, params]) => {
    // Add group header
    rows.push(new TableRow({
      children: [
        new TableCell({
          children: [new Paragraph({
            text: groupName,
            run: { bold: true, color: "0066CC" }
          })],
          columnSpan: 3
        })
      ]
    }));

    // Add parameters in this group
    params.forEach(param => {
      const value = rawParams[param] || 'N/A';
      rows.push(new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph("")], // Empty cell for category
            width: { size: 40, type: WidthType.PERCENTAGE }
          }),
          new TableCell({
            children: [new Paragraph(param)],
            width: { size: 35, type: WidthType.PERCENTAGE }
          }),
          new TableCell({
            children: [new Paragraph(String(value))],
            width: { size: 25, type: WidthType.PERCENTAGE }
          })
        ]
      }));
    });
  });

  // Add any additional parameters not in the predefined groups
  const definedParams = new Set(Object.values(parameterGroups).flat());
  const additionalParams = Object.keys(rawParams).filter(param => !definedParams.has(param));
  
  if (additionalParams.length > 0) {
    rows.push(new TableRow({
      children: [
        new TableCell({
          children: [new Paragraph({
            text: "Additional Parameters",
            run: { bold: true, color: "CC6600" }
          })],
          columnSpan: 3
        })
      ]
    }));

    additionalParams.forEach(param => {
      const value = rawParams[param];
      rows.push(new TableRow({
        children: [
          new TableCell({
            children: [new Paragraph("")], // Empty cell for category
            width: { size: 40, type: WidthType.PERCENTAGE }
          }),
          new TableCell({
            children: [new Paragraph(param)],
            width: { size: 35, type: WidthType.PERCENTAGE }
          }),
          new TableCell({
            children: [new Paragraph(String(value))],
            width: { size: 25, type: WidthType.PERCENTAGE }
          })
        ]
      }));
    });
  }

  return new Table({
    rows,
    width: { size: 100, type: WidthType.PERCENTAGE },
    borders: {
      top: { style: BorderStyle.SINGLE, size: 1 },
      bottom: { style: BorderStyle.SINGLE, size: 1 },
      left: { style: BorderStyle.SINGLE, size: 1 },
      right: { style: BorderStyle.SINGLE, size: 1 },
      insideHorizontal: { style: BorderStyle.SINGLE, size: 1 },
      insideVertical: { style: BorderStyle.SINGLE, size: 1 }
    }
  });
}

/**
 * Utility function to pad a string to a specific length
 * 
 * @param value The string value to pad
 * @param length The desired length
 * @returns The padded string
 */
function padString(value: string, length: number): string {
  if (!value) return ''.padStart(length, ' ');
  return value.toString().padStart(length, ' ');
}

/**
 * Helper function to get nested values from objects
 * 
 * @param obj The object to search in
 * @param path The path to the value
 * @returns The value or undefined
 */
function getNestedValue(obj: any, path: string): any {
  if (!obj || !path) return undefined;
  
  // Try to find the value by different mapping strategies
  const pathParts = path.split('_').slice(1); // Remove 'OBC1' prefix
  
  // Try direct property access first
  if (obj[path]) return obj[path];
  
  // Try camelCase conversion
  const camelCasePath = pathParts.map((part, index) => 
    index === 0 ? part.toLowerCase() : part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()
  ).join('');
  
  if (obj[camelCasePath]) return obj[camelCasePath];
  
  // Try other common patterns
  const simplePath = pathParts.join('').toLowerCase();
  if (obj[simplePath]) return obj[simplePath];
  
  return undefined;
}